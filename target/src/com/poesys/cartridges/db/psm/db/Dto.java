/**
 * Copyright 2009 Poesys Associates. All rights reserved.
 */
//
// Attention: Generated code! Do not modify by hand!
// Generated by: PSMmetaclass.vsl in andromda-meta-cartridge.
//
package com.poesys.cartridges.db.psm.db;

/**
 * 
 */
public abstract class Dto
{

    public Dto()
    {
        this.name = null;
        this.keyType = null;
        this.readWrite = false;
        this.superpackage = null;
        this.packageName = null;
        this.stereotypeNames = null;
        this.documentation = null;
        this.sqlTableName = null;
        this.abstractClass = false;
        this.immutable = false;
        this.removable = false;
        this.child = false;
        this.sequenceName = null;
        this.expiration = null;
        this.lazy = false;
        this.subsystem = null;
    }

    public Dto(java.lang.String name, java.lang.String keyType, boolean readWrite, java.lang.String superpackage, java.lang.String packageName, java.util.List stereotypeNames, java.lang.String documentation, java.lang.String sqlTableName, boolean abstractClass, boolean immutable, boolean removable, boolean child, java.lang.String sequenceName, java.lang.Integer expiration, boolean lazy, com.poesys.cartridges.db.psm.db.Subsystem subsystem)
    {
        this.name = name;
        this.keyType = keyType;
        this.readWrite = readWrite;
        this.superpackage = superpackage;
        this.packageName = packageName;
        this.stereotypeNames = stereotypeNames;
        this.documentation = documentation;
        this.sqlTableName = sqlTableName;
        this.abstractClass = abstractClass;
        this.immutable = immutable;
        this.removable = removable;
        this.child = child;
        this.sequenceName = sequenceName;
        this.expiration = expiration;
        this.lazy = lazy;
        this.subsystem = subsystem;
    }

    public Dto(java.lang.String name, java.lang.String keyType, boolean readWrite, java.lang.String superpackage, java.lang.String packageName, java.util.List stereotypeNames, java.lang.String documentation, java.lang.String sqlTableName, boolean abstractClass, boolean immutable, boolean removable, boolean child, java.lang.String sequenceName, java.lang.Integer expiration, boolean lazy, java.util.Collection dataMembers, com.poesys.cartridges.db.psm.db.Subsystem subsystem, java.util.Collection childProperties, java.util.Collection constructorArgs, java.util.List superclasses, java.util.Collection inheritedProperties, java.util.Collection keyProperties, com.poesys.cartridges.db.psm.db.Dto compositeParent, java.util.Collection subKeyProperties, java.util.List associatedDtos, java.util.List associatedKeys, java.util.Collection insertProperties, java.util.Collection localMembers, java.util.Collection objectProperties, java.util.Collection collectionProperties, java.util.Collection columns, java.util.List foreignKeys, java.util.List childDtos, java.util.Collection testVars, java.util.Collection inheritedConstructorArgs, java.util.Collection allDtoProperties, java.util.List subclasses)
    {
        this.name = name;
        this.keyType = keyType;
        this.readWrite = readWrite;
        this.superpackage = superpackage;
        this.packageName = packageName;
        this.stereotypeNames = stereotypeNames;
        this.documentation = documentation;
        this.sqlTableName = sqlTableName;
        this.abstractClass = abstractClass;
        this.immutable = immutable;
        this.removable = removable;
        this.child = child;
        this.sequenceName = sequenceName;
        this.expiration = expiration;
        this.lazy = lazy;
        this.dataMembers = dataMembers;
        this.subsystem = subsystem;
        this.childProperties = childProperties;
        this.constructorArgs = constructorArgs;
        this.superclasses = superclasses;
        this.inheritedProperties = inheritedProperties;
        this.keyProperties = keyProperties;
        this.compositeParent = compositeParent;
        this.subKeyProperties = subKeyProperties;
        this.associatedDtos = associatedDtos;
        this.associatedKeys = associatedKeys;
        this.insertProperties = insertProperties;
        this.localMembers = localMembers;
        this.objectProperties = objectProperties;
        this.collectionProperties = collectionProperties;
        this.columns = columns;
        this.foreignKeys = foreignKeys;
        this.childDtos = childDtos;
        this.testVars = testVars;
        this.inheritedConstructorArgs = inheritedConstructorArgs;
        this.allDtoProperties = allDtoProperties;
        this.subclasses = subclasses;
    }

    /**
     * Copy-constructor from other Dto
     *
     * @param otherBean, cannot be <code>null</code>
     * @throws java.lang.NullPointerException if the argument is <code>null</code>
     */
    public Dto(Dto otherBean)
    {
        this(otherBean.getName(), otherBean.getKeyType(), otherBean.isReadWrite(), otherBean.getSuperpackage(), otherBean.getPackageName(), otherBean.getStereotypeNames(), otherBean.getDocumentation(), otherBean.getSqlTableName(), otherBean.isAbstractClass(), otherBean.isImmutable(), otherBean.isRemovable(), otherBean.isChild(), otherBean.getSequenceName(), otherBean.getExpiration(), otherBean.isLazy(), otherBean.getDataMembers(), otherBean.getSubsystem(), otherBean.getChildProperties(), otherBean.getConstructorArgs(), otherBean.getSuperclasses(), otherBean.getInheritedProperties(), otherBean.getKeyProperties(), otherBean.getCompositeParent(), otherBean.getSubKeyProperties(), otherBean.getAssociatedDtos(), otherBean.getAssociatedKeys(), otherBean.getInsertProperties(), otherBean.getLocalMembers(), otherBean.getObjectProperties(), otherBean.getCollectionProperties(), otherBean.getColumns(), otherBean.getForeignKeys(), otherBean.getChildDtos(), otherBean.getTestVars(), otherBean.getInheritedConstructorArgs(), otherBean.getAllDtoProperties(), otherBean.getSubclasses());
    }

    protected java.lang.String name;

    /**
     * <p>
     * the DTO name; typically should follow Java class naming
     * conventions
     * </p>
     */
    public java.lang.String getName()
    {
        return this.name;
    }

    public void setName(java.lang.String name)
    {
        this.name = name;
    }

    protected java.lang.String keyType;

    /**
     * <p>
     * the kind of key (Natural, Composite, Sequence, Identity, Guid,
     * Association)
     * </p>
     */
    public java.lang.String getKeyType()
    {
        return this.keyType;
    }

    public void setKeyType(java.lang.String keyType)
    {
        this.keyType = keyType;
    }

    protected boolean readWrite = true;

    /**
     * <p>
     * whether the class is read/write (true) or read only (false);
     * used to enable insert/update/delete SQL commands (true) or to
     * suppress them (false)
     * </p>
     */
    public boolean isReadWrite()
    {
        return this.readWrite;
    }

    public void setReadWrite(boolean readWrite)
    {
        this.readWrite = readWrite;
    }

    protected java.lang.String superpackage;

    /**
     * <p>
     * he fully qualified Java package name of the superclass for this
     * DTO
     * </p>
     */
    public java.lang.String getSuperpackage()
    {
        return this.superpackage;
    }

    public void setSuperpackage(java.lang.String superpackage)
    {
        this.superpackage = superpackage;
    }

    protected java.lang.String packageName;

    /**
     * <p>
     * the fully qualified Java package name for the DTO class; the
     * namespace of the DTO
     * </p>
     */
    public java.lang.String getPackageName()
    {
        return this.packageName;
    }

    public void setPackageName(java.lang.String packageName)
    {
        this.packageName = packageName;
    }

    protected java.util.List stereotypeNames;

    /**
     * <p>
     * an ordered list of stereotype names for the DTO; the stereotype
     * names are the actual UML stereotypes, not the AndroMDA
     * intermediate strings
     * </p>
     */
    public java.util.List getStereotypeNames()
    {
        return this.stereotypeNames;
    }

    public void setStereotypeNames(java.util.List stereotypeNames)
    {
        this.stereotypeNames = stereotypeNames;
    }

    protected java.lang.String documentation;

    /**
     * <p>
     * the documentation for the DTO; appears in the class javadoc
     * comment
     * </p>
     */
    public java.lang.String getDocumentation()
    {
        return this.documentation;
    }

    public void setDocumentation(java.lang.String documentation)
    {
        this.documentation = documentation;
    }

    protected java.lang.String sqlTableName;

    /**
     * <p>
     * the SQL schema table name for the DTO; should follow an
     * appropriate SQL table naming convention, and should be limited
     * to 30 characters; used in SQL statement generation and
     * documentation
     * </p>
     */
    public java.lang.String getSqlTableName()
    {
        return this.sqlTableName;
    }

    public void setSqlTableName(java.lang.String sqlTableName)
    {
        this.sqlTableName = sqlTableName;
    }

    protected boolean abstractClass = false;

    /**
     * <p>
     * whether the DTO is abstract or concrete
     * </p>
     */
    public boolean isAbstractClass()
    {
        return this.abstractClass;
    }

    public void setAbstractClass(boolean abstractClass)
    {
        this.abstractClass = abstractClass;
    }

    protected boolean immutable = false;

    /**
     * <p>
     * whether the application can update objects of the class
     * </p>
     */
    public boolean isImmutable()
    {
        return this.immutable;
    }

    public void setImmutable(boolean immutable)
    {
        this.immutable = immutable;
    }

    protected boolean removable = true;

    /**
     * <p>
     * whether the application can remove or delete objects of the
     * class
     * </p>
     */
    public boolean isRemovable()
    {
        return this.removable;
    }

    public void setRemovable(boolean removable)
    {
        this.removable = removable;
    }

    protected boolean child = false;

    /**
     * <p>
     * whether the DTO a child (target of a composite aggregation or PK
     * association or association class)
     * </p>
     */
    public boolean isChild()
    {
        return this.child;
    }

    public void setChild(boolean child)
    {
        this.child = child;
    }

    protected java.lang.String sequenceName;

    /**
     * <p>
     * the name of the Oracle or MySQL sequence the delegate uses to
     * generate new keys for Dto objects
     * </p>
     */
    public java.lang.String getSequenceName()
    {
        return this.sequenceName;
    }

    public void setSequenceName(java.lang.String sequenceName)
    {
        this.sequenceName = sequenceName;
    }

    protected java.lang.Integer expiration;

    /**
     * <p>
     * the expiration time in milliseconds for an object cached in a
     * memory manager that supports object expiration; 0 means the
     * default value of the max integer size (Integer.MAX_VALUE); -1
     * means expire immediately (no caching)
     * </p>
     */
    public java.lang.Integer getExpiration()
    {
        return this.expiration;
    }

    public void setExpiration(java.lang.Integer expiration)
    {
        this.expiration = expiration;
    }

    protected boolean lazy = false;

    /**
     * <p>
     * whether this DTO is marked as always lazily loaded as an
     * association class
     * </p>
     */
    public boolean isLazy()
    {
        return this.lazy;
    }

    public void setLazy(boolean lazy)
    {
        this.lazy = lazy;
    }

    protected java.util.Collection dataMembers;

    /**
     * Get the dataMembers
     * <p>
     * the complete set of properties of the DTO, including association
     * properties and generated properties
     * </p>
     */
    public java.util.Collection getDataMembers()
    {
        return this.dataMembers;
    }

    /**
     * Sets the dataMembers
     */
    public void setDataMembers(java.util.Collection dataMembers)
    {
        this.dataMembers = dataMembers;
    }

    protected com.poesys.cartridges.db.psm.db.Subsystem subsystem;

    /**
     * Get the subsystem
     * 
     */
    public com.poesys.cartridges.db.psm.db.Subsystem getSubsystem()
    {
        return this.subsystem;
    }

    /**
     * Sets the subsystem
     */
    public void setSubsystem(com.poesys.cartridges.db.psm.db.Subsystem subsystem)
    {
        this.subsystem = subsystem;
    }

    protected java.util.Collection childProperties;

    /**
     * Get the childProperties
     * <p>
     * the set of properties that represent composite aggregations
     * (children in a parent-child association)
     * </p>
     */
    public java.util.Collection getChildProperties()
    {
        return this.childProperties;
    }

    /**
     * Sets the childProperties
     */
    public void setChildProperties(java.util.Collection childProperties)
    {
        this.childProperties = childProperties;
    }

    protected java.util.Collection constructorArgs;

    /**
     * Get the constructorArgs
     * <p>
     * the set of properties for the DTO that are queried from the
     * database, including generated properties, attributes, and to-one
     * associations but not to-many associations; the latter get
     * queried by setters separately
     * </p>
     */
    public java.util.Collection getConstructorArgs()
    {
        return this.constructorArgs;
    }

    /**
     * Sets the constructorArgs
     */
    public void setConstructorArgs(java.util.Collection constructorArgs)
    {
        this.constructorArgs = constructorArgs;
    }

    protected java.util.List superclasses;

    /**
     * Get the superclasses
     * <p>
     * The superclasses of the DTO starting from the root in
     * breadth-first order to support multiple inheritance
     * </p>
     */
    public java.util.List getSuperclasses()
    {
        return this.superclasses;
    }

    /**
     * Sets the superclasses
     */
    public void setSuperclasses(java.util.List superclasses)
    {
        this.superclasses = superclasses;
    }

    protected java.util.Collection inheritedProperties;

    /**
     * Get the inheritedProperties
     * <p>
     * the queried properties (attributes) inherited from the
     * superclass
     * </p>
     */
    public java.util.Collection getInheritedProperties()
    {
        return this.inheritedProperties;
    }

    /**
     * Sets the inheritedProperties
     */
    public void setInheritedProperties(java.util.Collection inheritedProperties)
    {
        this.inheritedProperties = inheritedProperties;
    }

    protected java.util.Collection keyProperties;

    /**
     * Get the keyProperties
     * 
     */
    public java.util.Collection getKeyProperties()
    {
        return this.keyProperties;
    }

    /**
     * Sets the keyProperties
     */
    public void setKeyProperties(java.util.Collection keyProperties)
    {
        this.keyProperties = keyProperties;
    }

    protected com.poesys.cartridges.db.psm.db.Dto compositeParent;

    /**
     * Get the compositeParent
     * 
     */
    public com.poesys.cartridges.db.psm.db.Dto getCompositeParent()
    {
        return this.compositeParent;
    }

    /**
     * Sets the compositeParent
     */
    public void setCompositeParent(com.poesys.cartridges.db.psm.db.Dto compositeParent)
    {
        this.compositeParent = compositeParent;
    }

    protected java.util.Collection subKeyProperties;

    /**
     * Get the subKeyProperties
     * 
     */
    public java.util.Collection getSubKeyProperties()
    {
        return this.subKeyProperties;
    }

    /**
     * Sets the subKeyProperties
     */
    public void setSubKeyProperties(java.util.Collection subKeyProperties)
    {
        this.subKeyProperties = subKeyProperties;
    }

    protected java.util.List associatedDtos;

    /**
     * Get the associatedDtos
     * <p>
     * an ordered list of DTOs that comprise the set of DTOs associated
     * by an association-class DTO (the current DTO); the ordering is
     * alphabetical by DTO name, taking case into account
     * </p>
     */
    public java.util.List getAssociatedDtos()
    {
        return this.associatedDtos;
    }

    /**
     * Sets the associatedDtos
     */
    public void setAssociatedDtos(java.util.List associatedDtos)
    {
        this.associatedDtos = associatedDtos;
    }

    protected java.util.List associatedKeys;

    /**
     * Get the associatedKeys
     * <p>
     * the set of keys that comprise the association key for an
     * association class; this corresponds to the N foreign keys for an
     * n-ary association class in the database. Note that this overlaps
     * with the set of foreign keys for the class but does not include
     * the to-one association foreign keys or inherited keys (since
     * association classes cannot be subclasses themselves).
     * </p>
     */
    public java.util.List getAssociatedKeys()
    {
        return this.associatedKeys;
    }

    /**
     * Sets the associatedKeys
     */
    public void setAssociatedKeys(java.util.List associatedKeys)
    {
        this.associatedKeys = associatedKeys;
    }

    protected java.util.Collection insertProperties;

    /**
     * Get the insertProperties
     * 
     */
    public java.util.Collection getInsertProperties()
    {
        return this.insertProperties;
    }

    /**
     * Sets the insertProperties
     */
    public void setInsertProperties(java.util.Collection insertProperties)
    {
        this.insertProperties = insertProperties;
    }

    protected java.util.Collection localMembers;

    /**
     * Get the localMembers
     * 
     */
    public java.util.Collection getLocalMembers()
    {
        return this.localMembers;
    }

    /**
     * Sets the localMembers
     */
    public void setLocalMembers(java.util.Collection localMembers)
    {
        this.localMembers = localMembers;
    }

    protected java.util.Collection objectProperties;

    /**
     * Get the objectProperties
     * <p>
     * the set of properties containing the to-one associated objects
     * for the class; these are association ends with a single object
     * </p>
     */
    public java.util.Collection getObjectProperties()
    {
        return this.objectProperties;
    }

    /**
     * Sets the objectProperties
     */
    public void setObjectProperties(java.util.Collection objectProperties)
    {
        this.objectProperties = objectProperties;
    }

    protected java.util.Collection collectionProperties;

    /**
     * Get the collectionProperties
     * 
     */
    public java.util.Collection getCollectionProperties()
    {
        return this.collectionProperties;
    }

    /**
     * Sets the collectionProperties
     */
    public void setCollectionProperties(java.util.Collection collectionProperties)
    {
        this.collectionProperties = collectionProperties;
    }

    protected java.util.Collection columns;

    /**
     * Get the columns
     * 
     */
    public java.util.Collection getColumns()
    {
        return this.columns;
    }

    /**
     * Sets the columns
     */
    public void setColumns(java.util.Collection columns)
    {
        this.columns = columns;
    }

    protected java.util.List foreignKeys;

    /**
     * Get the foreignKeys
     * <p>
     * <html>
     * </p>
     * <p>
     * <head>
     * </p>
     * <p>
     * </head>
     * </p>
     * <p>
     * <body>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * The foreign keys for the DTO. These are of two types:
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * <ul>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * <li>the key columns of a primary key inherited from a
     * superclass</li>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * <li>the key columns of single associated objects (to-one
     * association
     * </p>
     * <p>
     * links)
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </li>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </ul>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * The schema generator uses this list to build the ALTER TABLE
     * statements
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * that add the foreign keys to the schema. The keys are sorted by
     * name so
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * they always come out in the same order
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * Each associated key may contain any number of key properties,
     * which
     * </p>
     * <p>
     * correspond to the multiple properties of the key of the
     * associated
     * </p>
     * <p>
     * object. A foreign key constraint may thus map multiple columns
     * to
     * </p>
     * <p>
     * multiple columns based on these multiple properties of the
     * associated
     * </p>
     * <p>
     * key.
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * Note that this list of keys does not include the associated keys
     * for
     * </p>
     * <p>
     * single
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * associated objects inherited from superclasses; the foreign key
     * is set at
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * the superclass level in the database, not for all levels of the
     * </p>
     * <p>
     * inheritance
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * hierarchy.
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * </body>
     * </p>
     * <p>
     * </html>
     * </p>
     */
    public java.util.List getForeignKeys()
    {
        return this.foreignKeys;
    }

    /**
     * Sets the foreignKeys
     */
    public void setForeignKeys(java.util.List foreignKeys)
    {
        this.foreignKeys = foreignKeys;
    }

    protected java.util.List childDtos;

    /**
     * Get the childDtos
     * <p>
     * The ordered list of child DTOs of this DTO; a child DTO is a
     * target of a composite aggregation where the source is this DTO
     * (the parent) or an association class that represents a
     * many-to-many association; the order is the dependency order from
     * bottom to top, the order in which to delete or truncate rows
     * from the tables without violating foreign key dependencies
     * </p>
     */
    public java.util.List getChildDtos()
    {
        return this.childDtos;
    }

    /**
     * Sets the childDtos
     */
    public void setChildDtos(java.util.List childDtos)
    {
        this.childDtos = childDtos;
    }

    protected java.util.Collection testVars;

    /**
     * Get the testVars
     * <p>
     * the set of local test variables in the JUnit test class create
     * method
     * </p>
     */
    public java.util.Collection getTestVars()
    {
        return this.testVars;
    }

    /**
     * Sets the testVars
     */
    public void setTestVars(java.util.Collection testVars)
    {
        this.testVars = testVars;
    }

    protected java.util.Collection inheritedConstructorArgs;

    /**
     * Get the inheritedConstructorArgs
     * 
     */
    public java.util.Collection getInheritedConstructorArgs()
    {
        return this.inheritedConstructorArgs;
    }

    /**
     * Sets the inheritedConstructorArgs
     */
    public void setInheritedConstructorArgs(java.util.Collection inheritedConstructorArgs)
    {
        this.inheritedConstructorArgs = inheritedConstructorArgs;
    }

    protected java.util.Collection allDtoProperties;

    /**
     * Get the allDtoProperties
     * 
     */
    public java.util.Collection getAllDtoProperties()
    {
        return this.allDtoProperties;
    }

    /**
     * Sets the allDtoProperties
     */
    public void setAllDtoProperties(java.util.Collection allDtoProperties)
    {
        this.allDtoProperties = allDtoProperties;
    }

    protected java.util.List subclasses;

    /**
     * Get the subclasses
     * <p>
     * the set of subclasses of the DTO class in depth-first order
     * (concrete subclasses first)
     * </p>
     */
    public java.util.List getSubclasses()
    {
        return this.subclasses;
    }

    /**
     * Sets the subclasses
     */
    public void setSubclasses(java.util.List subclasses)
    {
        this.subclasses = subclasses;
    }

    /**
     * <p>
     * Get the Poesys/DB fully qualified class name for the specific
     * type of primary key, based on the key type of the class; if the
     * key type is None, this returns the inherited key type or null if
     * there is no key type at all
     * </p>
     */
    public abstract java.lang.String getKeyClass();

    /**
     * <p>
     * For a DTO with the keyType = "None", return the key type of the
     * nearest superclass DTO with a keyType other than "None", if any.
     * </p>
     */
    public abstract java.lang.String getInheritedKeyType();

    /**
     * <p>
     * Get the immediate superclass of the DTO (the last DTO in the
     * list of superclasses)
     * </p>
     */
    public abstract java.lang.String getSuperclass();

    /**
     * <p>
     * Get the class name transformed into the appropriate format to
     * use as a property name, usually the name with the first
     * character lower-cased.
     * </p>
     */
    public abstract java.lang.String getNameAsProperty();

    /**
     * <p>
     * Get the alias to use in the WHERE clause for an object query. If
     * the DTO has superclasses, the alias will be the name of the
     * superclass closest to the DTO with a keytype, which is the class
     * from which the DTO inherits its primary key. If the DTO has no
     * superclasses, the alias is a blank string "".
     * </p>
     */
    public abstract java.lang.String getObjectQueryAlias();

    /**
     * <p>
     * Get the associated foreign key specified by the key property
     * name.
     * </p>
     */
    public abstract com.poesys.cartridges.db.psm.db.AssociatedKey getForeignKey(java.lang.String name);

    /**
     * <p>
     * Get a unique name for the DTO that includes the full package
     * name as a prefix using the standard init-cap Java convention.
     * org.tair.test.MyClass becomes OrgTairTestMyClass.
     * </p>
     */
    public abstract java.lang.String getUniqueName();

    /**
     * <p>
     * Does this DTO have any lazily loaded members?
     * </p>
     */
    public abstract boolean hasLazilyLoadedMember();

    /**
     * <p>
     * Get the list of column names for the INSERT statement(s)
     * </p>
     */
    public abstract java.lang.String getSqlInsertList();

    /**
     * <p>
     * Get the list of SQL column names for the SELECT list(s)
     * </p>
     */
    public abstract java.lang.String getSqlSelectList();

    /**
     * <p>
     * <p>
     * </p>
     * <p>
     * Get the SQL FROM clause for the Query classes. By default, this
     * is just the SQL table name. For classes that have superclasses,
     * it is a series of JOIN clauses that walk the superclass tree to
     * the root to query all the inherited properties for a leaf class.
     * The returned string has no "FROM" keyword and can be null if the
     * current class is abstract. The table aliases will be the table
     * names. The method handles multiple inheritance. All the
     * superclass tables join to the current class table directly. For
     * example, if you have A, B, and C (C-->B-->A), the FROM clause
     * looks like this:
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <pre>
     * </p>
     * <p>
     * C AS C JOIN B AS B ON C.aId = B.aId JOIN A AS A ON C.aId = A.aId
     * </p>
     * <p>
     * </pre>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * The strategy uses the assumption that the subclass inherits the
     * primary key. You must have a set of attributes in the subclass
     * with the same names as the primary key attributes in the
     * superclass, and the value of the attributes must match (foreign
     * key).
     * </p>
     * <p>
     * </p>
     * </p>
     */
    public abstract java.lang.String getSqlFromClause();

    /**
     * <p>
     * Get the name of the root superclass in the set of superclasses.
     * This class is the top of the chain of superclasses. If there are
     * no superclasses, the method returns the current class (the DTO).
     * </p>
     */
    public abstract java.lang.String getRootSuperclass();

    /**
     * <p>
     * Get the fully qualified package name of the root superclass of
     * the current DTO class. If there is no superclass, the method
     * returns the fully qualified package name of the current DTO
     * class.
     * </p>
     */
    public abstract java.lang.String getRootSuperclassPackage();

    /**
     * <p>
     * Add the subclasses of a specified class to the FROM clause in a
     * string builder instance. The method recursively walks up the
     * tree of subclasses starting from the leaves and adds LEFT OUTER
     * JOIN clauses to the FROM clause.
     * </p>
     */
    public abstract java.lang.StringBuilder addSubclassesToFromClause(java.util.List subclasses, java.lang.String leafAlias, java.lang.StringBuilder fromClause);

    /**
     * <p>
     * Add the superclasses of a specified class to the FROM clause in
     * a string builder instance. The method recursively walks up the
     * tree of superclasses starting from the leaves and adds LEFT
     * OUTER JOIN clauses to the FROM clause.
     * </p>
     */
    public abstract java.lang.StringBuilder addSuperclassesToFromClause(java.util.List superclasses, java.lang.String leafAlias, java.lang.StringBuilder fromClause);


}