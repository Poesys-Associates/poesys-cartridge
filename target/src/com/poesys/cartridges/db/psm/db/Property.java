/**
 * Copyright 2009 Poesys Associates. All rights reserved.
 */
//
// Attention: Generated code! Do not modify by hand!
// Generated by: PSMmetaclass.vsl in andromda-meta-cartridge.
//
package com.poesys.cartridges.db.psm.db;

/**
 * 
 */
public abstract class Property
{

    public Property()
    {
        this.name = null;
        this.uniqueGroup = null;
        this.length = null;
        this.precision = null;
        this.scale = null;
        this.readWrite = false;
        this.key = false;
        this.typeName = null;
        this.documentation = null;
        this.visibility = null;
        this.toMany = false;
        this.required = false;
        this.defaultValue = null;
        this.paramTag = null;
        this.sqlType = null;
        this.pkColType = null;
        this.subsystem = null;
        this.associationEnd = false;
        this.source = null;
        this.tableName = null;
        this.lazy = false;
        this.child = false;
        this.className = null;
        this.immutable = false;
        this.removable = false;
        this.classKeyType = null;
        this.ordered = false;
        this.originalName = null;
        this.fetchSize = null;
        this.batchSize = null;
        this.bsTypeName = null;
        this.sqlTypeAnsi = null;
        this.sqlTypeMySql51 = null;
        this.sqlTypeOracle11g = null;
        this.sqlTypeSybaseAse125 = null;
        this.parentKey = false;
        this.explicitName = null;
        this.prefix = null;
        this.booleanString = false;
        this.booleanTrue = null;
        this.booleanFalse = null;
        this.objectName = null;
    }

    public Property(java.lang.String name, java.lang.String uniqueGroup, java.lang.Long length, java.lang.Integer precision, java.lang.Integer scale, boolean readWrite, boolean key, java.lang.String typeName, java.lang.String documentation, java.lang.String visibility, boolean toMany, boolean required, java.lang.String defaultValue, java.lang.String paramTag, java.lang.String sqlType, java.lang.String pkColType, java.lang.String subsystem, boolean associationEnd, java.lang.String source, java.lang.String tableName, boolean lazy, boolean child, java.lang.String className, boolean immutable, boolean removable, java.lang.String classKeyType, boolean ordered, java.lang.String originalName, java.lang.Integer fetchSize, java.lang.Integer batchSize, java.lang.String bsTypeName, java.lang.String sqlTypeAnsi, java.lang.String sqlTypeMySql51, java.lang.String sqlTypeOracle11g, java.lang.String sqlTypeSybaseAse125, boolean parentKey, java.lang.String explicitName, java.lang.String prefix, boolean booleanString, java.lang.String booleanTrue, java.lang.String booleanFalse, java.lang.String objectName)
    {
        this.name = name;
        this.uniqueGroup = uniqueGroup;
        this.length = length;
        this.precision = precision;
        this.scale = scale;
        this.readWrite = readWrite;
        this.key = key;
        this.typeName = typeName;
        this.documentation = documentation;
        this.visibility = visibility;
        this.toMany = toMany;
        this.required = required;
        this.defaultValue = defaultValue;
        this.paramTag = paramTag;
        this.sqlType = sqlType;
        this.pkColType = pkColType;
        this.subsystem = subsystem;
        this.associationEnd = associationEnd;
        this.source = source;
        this.tableName = tableName;
        this.lazy = lazy;
        this.child = child;
        this.className = className;
        this.immutable = immutable;
        this.removable = removable;
        this.classKeyType = classKeyType;
        this.ordered = ordered;
        this.originalName = originalName;
        this.fetchSize = fetchSize;
        this.batchSize = batchSize;
        this.bsTypeName = bsTypeName;
        this.sqlTypeAnsi = sqlTypeAnsi;
        this.sqlTypeMySql51 = sqlTypeMySql51;
        this.sqlTypeOracle11g = sqlTypeOracle11g;
        this.sqlTypeSybaseAse125 = sqlTypeSybaseAse125;
        this.parentKey = parentKey;
        this.explicitName = explicitName;
        this.prefix = prefix;
        this.booleanString = booleanString;
        this.booleanTrue = booleanTrue;
        this.booleanFalse = booleanFalse;
        this.objectName = objectName;
    }

    public Property(java.lang.String name, java.lang.String uniqueGroup, java.lang.Long length, java.lang.Integer precision, java.lang.Integer scale, boolean readWrite, boolean key, java.lang.String typeName, java.lang.String documentation, java.lang.String visibility, boolean toMany, boolean required, java.lang.String defaultValue, java.lang.String paramTag, java.lang.String sqlType, java.lang.String pkColType, java.lang.String subsystem, boolean associationEnd, java.lang.String source, java.lang.String tableName, boolean lazy, boolean child, java.lang.String className, boolean immutable, boolean removable, java.lang.String classKeyType, boolean ordered, java.lang.String originalName, java.lang.Integer fetchSize, java.lang.Integer batchSize, java.lang.String bsTypeName, java.lang.String sqlTypeAnsi, java.lang.String sqlTypeMySql51, java.lang.String sqlTypeOracle11g, java.lang.String sqlTypeSybaseAse125, boolean parentKey, java.lang.String explicitName, java.lang.String prefix, boolean booleanString, java.lang.String booleanTrue, java.lang.String booleanFalse, java.lang.String objectName, com.poesys.cartridges.db.psm.db.Dto dto, java.util.List prefixes, com.poesys.cartridges.db.psm.db.Dto owner, com.poesys.cartridges.db.psm.db.Dto inheritedFrom)
    {
        this.name = name;
        this.uniqueGroup = uniqueGroup;
        this.length = length;
        this.precision = precision;
        this.scale = scale;
        this.readWrite = readWrite;
        this.key = key;
        this.typeName = typeName;
        this.documentation = documentation;
        this.visibility = visibility;
        this.toMany = toMany;
        this.required = required;
        this.defaultValue = defaultValue;
        this.paramTag = paramTag;
        this.sqlType = sqlType;
        this.pkColType = pkColType;
        this.subsystem = subsystem;
        this.associationEnd = associationEnd;
        this.source = source;
        this.tableName = tableName;
        this.lazy = lazy;
        this.child = child;
        this.className = className;
        this.immutable = immutable;
        this.removable = removable;
        this.classKeyType = classKeyType;
        this.ordered = ordered;
        this.originalName = originalName;
        this.fetchSize = fetchSize;
        this.batchSize = batchSize;
        this.bsTypeName = bsTypeName;
        this.sqlTypeAnsi = sqlTypeAnsi;
        this.sqlTypeMySql51 = sqlTypeMySql51;
        this.sqlTypeOracle11g = sqlTypeOracle11g;
        this.sqlTypeSybaseAse125 = sqlTypeSybaseAse125;
        this.parentKey = parentKey;
        this.explicitName = explicitName;
        this.prefix = prefix;
        this.booleanString = booleanString;
        this.booleanTrue = booleanTrue;
        this.booleanFalse = booleanFalse;
        this.objectName = objectName;
        this.dto = dto;
        this.prefixes = prefixes;
        this.owner = owner;
        this.inheritedFrom = inheritedFrom;
    }

    /**
     * Copy-constructor from other Property
     *
     * @param otherBean, cannot be <code>null</code>
     * @throws java.lang.NullPointerException if the argument is <code>null</code>
     */
    public Property(Property otherBean)
    {
        this(otherBean.getName(), otherBean.getUniqueGroup(), otherBean.getLength(), otherBean.getPrecision(), otherBean.getScale(), otherBean.isReadWrite(), otherBean.isKey(), otherBean.getTypeName(), otherBean.getDocumentation(), otherBean.getVisibility(), otherBean.isToMany(), otherBean.isRequired(), otherBean.getDefaultValue(), otherBean.getParamTag(), otherBean.getSqlType(), otherBean.getPkColType(), otherBean.getSubsystem(), otherBean.isAssociationEnd(), otherBean.getSource(), otherBean.getTableName(), otherBean.isLazy(), otherBean.isChild(), otherBean.getClassName(), otherBean.isImmutable(), otherBean.isRemovable(), otherBean.getClassKeyType(), otherBean.isOrdered(), otherBean.getOriginalName(), otherBean.getFetchSize(), otherBean.getBatchSize(), otherBean.getBsTypeName(), otherBean.getSqlTypeAnsi(), otherBean.getSqlTypeMySql51(), otherBean.getSqlTypeOracle11g(), otherBean.getSqlTypeSybaseAse125(), otherBean.isParentKey(), otherBean.getExplicitName(), otherBean.getPrefix(), otherBean.isBooleanString(), otherBean.getBooleanTrue(), otherBean.getBooleanFalse(), otherBean.getObjectName(), otherBean.getDto(), otherBean.getPrefixes(), otherBean.getOwner(), otherBean.getInheritedFrom());
    }

    protected java.lang.String name;

    /**
     * 
     */
    public java.lang.String getName()
    {
        return this.name;
    }

    public void setName(java.lang.String name)
    {
        this.name = name;
    }

    protected java.lang.String uniqueGroup;

    /**
     * 
     */
    public java.lang.String getUniqueGroup()
    {
        return this.uniqueGroup;
    }

    public void setUniqueGroup(java.lang.String uniqueGroup)
    {
        this.uniqueGroup = uniqueGroup;
    }

    protected java.lang.Long length;

    /**
     * 
     */
    public java.lang.Long getLength()
    {
        return this.length;
    }

    public void setLength(java.lang.Long length)
    {
        this.length = length;
    }

    protected java.lang.Integer precision;

    /**
     * 
     */
    public java.lang.Integer getPrecision()
    {
        return this.precision;
    }

    public void setPrecision(java.lang.Integer precision)
    {
        this.precision = precision;
    }

    protected java.lang.Integer scale;

    /**
     * 
     */
    public java.lang.Integer getScale()
    {
        return this.scale;
    }

    public void setScale(java.lang.Integer scale)
    {
        this.scale = scale;
    }

    protected boolean readWrite = true;

    /**
     * <p>
     * Whether the property is read/write (true) or read only (false);
     * used to suppress the setter if false
     * </p>
     */
    public boolean isReadWrite()
    {
        return this.readWrite;
    }

    public void setReadWrite(boolean readWrite)
    {
        this.readWrite = readWrite;
    }

    protected boolean key = false;

    /**
     * 
     */
    public boolean isKey()
    {
        return this.key;
    }

    public void setKey(boolean key)
    {
        this.key = key;
    }

    protected java.lang.String typeName;

    /**
     * <p>
     * the complete type name of the property, including template
     * </p>
     */
    public java.lang.String getTypeName()
    {
        return this.typeName;
    }

    public void setTypeName(java.lang.String typeName)
    {
        this.typeName = typeName;
    }

    protected java.lang.String documentation;

    /**
     * 
     */
    public java.lang.String getDocumentation()
    {
        return this.documentation;
    }

    public void setDocumentation(java.lang.String documentation)
    {
        this.documentation = documentation;
    }

    protected java.lang.String visibility;

    /**
     * 
     */
    public java.lang.String getVisibility()
    {
        return this.visibility;
    }

    public void setVisibility(java.lang.String visibility)
    {
        this.visibility = visibility;
    }

    protected boolean toMany = false;

    /**
     * <p>
     * Whether the accessor represents a to-many association or not (a
     * Collection or List data type)
     * </p>
     */
    public boolean isToMany()
    {
        return this.toMany;
    }

    public void setToMany(boolean toMany)
    {
        this.toMany = toMany;
    }

    protected boolean required = false;

    /**
     * <p>
     * whether the property is required (cannot be null)
     * </p>
     */
    public boolean isRequired()
    {
        return this.required;
    }

    public void setRequired(boolean required)
    {
        this.required = required;
    }

    protected java.lang.String defaultValue;

    /**
     * <p>
     * the default value to assign to the property
     * </p>
     */
    public java.lang.String getDefaultValue()
    {
        return this.defaultValue;
    }

    public void setDefaultValue(java.lang.String defaultValue)
    {
        this.defaultValue = defaultValue;
    }

    protected java.lang.String paramTag;

    /**
     * 
     */
    public java.lang.String getParamTag()
    {
        return this.paramTag;
    }

    public void setParamTag(java.lang.String paramTag)
    {
        this.paramTag = paramTag;
    }

    protected java.lang.String sqlType;

    /**
     * 
     */
    public java.lang.String getSqlType()
    {
        return this.sqlType;
    }

    public void setSqlType(java.lang.String sqlType)
    {
        this.sqlType = sqlType;
    }

    protected java.lang.String pkColType;

    /**
     * 
     */
    public java.lang.String getPkColType()
    {
        return this.pkColType;
    }

    public void setPkColType(java.lang.String pkColType)
    {
        this.pkColType = pkColType;
    }

    protected java.lang.String subsystem;

    /**
     * 
     */
    public java.lang.String getSubsystem()
    {
        return this.subsystem;
    }

    public void setSubsystem(java.lang.String subsystem)
    {
        this.subsystem = subsystem;
    }

    protected boolean associationEnd = false;

    /**
     * <p>
     * whether the property is an association end (true) or an
     * attribute (false)
     * </p>
     */
    public boolean isAssociationEnd()
    {
        return this.associationEnd;
    }

    public void setAssociationEnd(boolean associationEnd)
    {
        this.associationEnd = associationEnd;
    }

    protected java.lang.String source;

    /**
     * <p>
     * The nested Add class that is the source of the property; for
     * debugging multiple-property problems
     * </p>
     */
    public java.lang.String getSource()
    {
        return this.source;
    }

    public void setSource(java.lang.String source)
    {
        this.source = source;
    }

    protected java.lang.String tableName;

    /**
     * <p>
     * the name of the database table that contains the property
     * </p>
     */
    public java.lang.String getTableName()
    {
        return this.tableName;
    }

    public void setTableName(java.lang.String tableName)
    {
        this.tableName = tableName;
    }

    protected boolean lazy = false;

    /**
     * 
     */
    public boolean isLazy()
    {
        return this.lazy;
    }

    public void setLazy(boolean lazy)
    {
        this.lazy = lazy;
    }

    protected boolean child = false;

    /**
     * 
     */
    public boolean isChild()
    {
        return this.child;
    }

    public void setChild(boolean child)
    {
        this.child = child;
    }

    protected java.lang.String className;

    /**
     * <p>
     * The name of the class of the object or objects the property
     * holds; same as the type name for single-object properties,
     * different for multiple-object collection properties (but
     * embedded in the generic template instantiation)
     * </p>
     */
    public java.lang.String getClassName()
    {
        return this.className;
    }

    public void setClassName(java.lang.String className)
    {
        this.className = className;
    }

    protected boolean immutable = false;

    /**
     * <p>
     * whether the application can change objects associated to the
     * class through this property (whether the opposite class is
     * immutable)
     * </p>
     */
    public boolean isImmutable()
    {
        return this.immutable;
    }

    public void setImmutable(boolean immutable)
    {
        this.immutable = immutable;
    }

    protected boolean removable = true;

    /**
     * <p>
     * whether the application can remove or delete objects associated
     * to the class through this property (whether the opposite class
     * is removable)
     * </p>
     */
    public boolean isRemovable()
    {
        return this.removable;
    }

    public void setRemovable(boolean removable)
    {
        this.removable = removable;
    }

    protected java.lang.String classKeyType;

    /**
     * <p>
     * The key type of the class of the property object; null if the
     * property is not an object type (a data type)
     * </p>
     */
    public java.lang.String getClassKeyType()
    {
        return this.classKeyType;
    }

    public void setClassKeyType(java.lang.String classKeyType)
    {
        this.classKeyType = classKeyType;
    }

    protected boolean ordered = false;

    /**
     * <p>
     * whether a to-many association end property is ordered (a List)
     * or not (a Collection)
     * </p>
     */
    public boolean isOrdered()
    {
        return this.ordered;
    }

    public void setOrdered(boolean ordered)
    {
        this.ordered = ordered;
    }

    protected java.lang.String originalName;

    /**
     * <p>
     * the original name of the attribute before modification to handle
     * duplicate names; used also in mapping foreign keys back to the
     * primary key attribute
     * </p>
     */
    public java.lang.String getOriginalName()
    {
        return this.originalName;
    }

    public void setOriginalName(java.lang.String originalName)
    {
        this.originalName = originalName;
    }

    protected java.lang.Integer fetchSize;

    /**
     * <p>
     * the JDBC fetch size for the to-many property; not used for
     * to-one properties
     * </p>
     */
    public java.lang.Integer getFetchSize()
    {
        return this.fetchSize;
    }

    public void setFetchSize(java.lang.Integer fetchSize)
    {
        this.fetchSize = fetchSize;
    }

    protected java.lang.Integer batchSize;

    /**
     * 
     */
    public java.lang.Integer getBatchSize()
    {
        return this.batchSize;
    }

    public void setBatchSize(java.lang.Integer batchSize)
    {
        this.batchSize = batchSize;
    }

    protected java.lang.String bsTypeName;

    /**
     * <p>
     * the business-layer type name for the type; for "primitive"
     * attributes, this is the same as typeName; for object attributes,
     * this is the fully-qualified business-layer DTO name.
     * </p>
     */
    public java.lang.String getBsTypeName()
    {
        return this.bsTypeName;
    }

    public void setBsTypeName(java.lang.String bsTypeName)
    {
        this.bsTypeName = bsTypeName;
    }

    protected java.lang.String sqlTypeAnsi;

    /**
     * <p>
     * ANSI SQL data type for the column
     * </p>
     */
    public java.lang.String getSqlTypeAnsi()
    {
        return this.sqlTypeAnsi;
    }

    public void setSqlTypeAnsi(java.lang.String sqlTypeAnsi)
    {
        this.sqlTypeAnsi = sqlTypeAnsi;
    }

    protected java.lang.String sqlTypeMySql51;

    /**
     * <p>
     * MySQL 5.1 SQL data type for the column
     * </p>
     */
    public java.lang.String getSqlTypeMySql51()
    {
        return this.sqlTypeMySql51;
    }

    public void setSqlTypeMySql51(java.lang.String sqlTypeMySql51)
    {
        this.sqlTypeMySql51 = sqlTypeMySql51;
    }

    protected java.lang.String sqlTypeOracle11g;

    /**
     * <p>
     * Oracle11g SQL data type for the column
     * </p>
     */
    public java.lang.String getSqlTypeOracle11g()
    {
        return this.sqlTypeOracle11g;
    }

    public void setSqlTypeOracle11g(java.lang.String sqlTypeOracle11g)
    {
        this.sqlTypeOracle11g = sqlTypeOracle11g;
    }

    protected java.lang.String sqlTypeSybaseAse125;

    /**
     * <p>
     * Sybase ASE 12.5 data type for the column
     * </p>
     */
    public java.lang.String getSqlTypeSybaseAse125()
    {
        return this.sqlTypeSybaseAse125;
    }

    public void setSqlTypeSybaseAse125(java.lang.String sqlTypeSybaseAse125)
    {
        this.sqlTypeSybaseAse125 = sqlTypeSybaseAse125;
    }

    protected boolean parentKey = false;

    /**
     * <p>
     * Is this property a parent key? That is, is the property a
     * primary key property in a composite aggregation target that
     * comes from the parent class?
     * </p>
     */
    public boolean isParentKey()
    {
        return this.parentKey;
    }

    public void setParentKey(boolean parentKey)
    {
        this.parentKey = parentKey;
    }

    protected java.lang.String explicitName;

    /**
     * <p>
     * an explicit name for the property specified in some kind of
     * tagged value; entirely replaces the name in the getUniqueName()
     * method
     * </p>
     */
    public java.lang.String getExplicitName()
    {
        return this.explicitName;
    }

    public void setExplicitName(java.lang.String explicitName)
    {
        this.explicitName = explicitName;
    }

    protected java.lang.String prefix;

    /**
     * <p>
     * the string with which to prefix the property name if a unique
     * name is required and there is no explicit name
     * </p>
     */
    public java.lang.String getPrefix()
    {
        return this.prefix;
    }

    public void setPrefix(java.lang.String prefix)
    {
        this.prefix = prefix;
    }

    protected boolean booleanString = false;

    /**
     * <p>
     * whether this property has the BooleanString stereotype; note
     * that the type must be Boolean or boolean for the BooleanString
     * representation to have any effect
     * </p>
     */
    public boolean isBooleanString()
    {
        return this.booleanString;
    }

    public void setBooleanString(boolean booleanString)
    {
        this.booleanString = booleanString;
    }

    protected java.lang.String booleanTrue;

    /**
     * <p>
     * the optional string that represents a Boolean true value in the
     * database
     * </p>
     */
    public java.lang.String getBooleanTrue()
    {
        return this.booleanTrue;
    }

    public void setBooleanTrue(java.lang.String booleanTrue)
    {
        this.booleanTrue = booleanTrue;
    }

    protected java.lang.String booleanFalse;

    /**
     * <p>
     * the optional string that represents a Boolean false value in the
     * database
     * </p>
     */
    public java.lang.String getBooleanFalse()
    {
        return this.booleanFalse;
    }

    public void setBooleanFalse(java.lang.String booleanFalse)
    {
        this.booleanFalse = booleanFalse;
    }

    protected java.lang.String objectName;

    /**
     * <p>
     * For an association end property, where the opposite end is an
     * association class, this name represents the name of the object
     * in the PSM class corresponding to the association class that
     * represents the associated object. This name lets you name that
     * object with a singular name but use a plural name for the
     * association end itself. The association end name is then used to
     * represent the link name in the associated classes (also linked
     * to the association class). This name can also be used at the
     * persistent store level as a name for a foreign key constraint.
     * </p>
     */
    public java.lang.String getObjectName()
    {
        return this.objectName;
    }

    public void setObjectName(java.lang.String objectName)
    {
        this.objectName = objectName;
    }

    protected com.poesys.cartridges.db.psm.db.Dto dto;

    /**
     * Get the dto
     * <p>
     * the DTO corresponding to the persistent object type of the
     * property; applies only to object properties, not primitive data
     * type properties; this is the DTO type of the property, not the
     * DTO type of the DTO that owns the property (in other words, the
     * DTO type of the foreign key value, not the DTO type of the class
     * that owns the foreign key attribute)
     * </p>
     */
    public com.poesys.cartridges.db.psm.db.Dto getDto()
    {
        return this.dto;
    }

    /**
     * Sets the dto
     */
    public void setDto(com.poesys.cartridges.db.psm.db.Dto dto)
    {
        this.dto = dto;
    }

    protected java.util.List prefixes;

    /**
     * Get the prefixes
     * <p>
     * the ordered list of prefixes for an association class property;
     * the ordering is left to right.
     * </p>
     */
    public java.util.List getPrefixes()
    {
        return this.prefixes;
    }

    /**
     * Sets the prefixes
     */
    public void setPrefixes(java.util.List prefixes)
    {
        this.prefixes = prefixes;
    }

    protected com.poesys.cartridges.db.psm.db.Dto owner;

    /**
     * Get the owner
     * <p>
     * the DTO type of the class that owns the property (as opposed to
     * the DTO type of the property itself)
     * </p>
     */
    public com.poesys.cartridges.db.psm.db.Dto getOwner()
    {
        return this.owner;
    }

    /**
     * Sets the owner
     */
    public void setOwner(com.poesys.cartridges.db.psm.db.Dto owner)
    {
        this.owner = owner;
    }

    protected com.poesys.cartridges.db.psm.db.Dto inheritedFrom;

    /**
     * Get the inheritedFrom
     * 
     */
    public com.poesys.cartridges.db.psm.db.Dto getInheritedFrom()
    {
        return this.inheritedFrom;
    }

    /**
     * Sets the inheritedFrom
     */
    public void setInheritedFrom(com.poesys.cartridges.db.psm.db.Dto inheritedFrom)
    {
        this.inheritedFrom = inheritedFrom;
    }

    /**
     * <p>
     * Prefix the name of the property with a specified string
     * </p>
     */
    public abstract void prefix(java.lang.String prefix);

    /**
     * <p>
     * Get the getter name ("get" or "is" based on the data type and
     * name of the accessor
     * </p>
     */
    public abstract java.lang.String getGetterName();

    /**
     * <p>
     * Get the setter accessor name based on the accessor name prefixed
     * by "set".
     * </p>
     */
    public abstract java.lang.String getSetterName();

    /**
     * <p>
     * <p>
     * </p>
     * <p>
     * Gets a unique name for the property.
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * <ol>
     * </p>
     * <p>
     * <li>If the property is not an association end, use the property
     * name.</li>
     * </p>
     * <p>
     * <li>Otherwise, if there is an explicit name for the property,
     * and that makes the name unique, use that.</li>
     * </p>
     * <p>
     * <li>Otherwise, if there is an explicit name for the property
     * that is not unique, prefix the explicit name with the prefix.
     * </li>
     * </p>
     * <p>
     * <li>Otherwise, prefix the name with the prefix.</li>
     * </p>
     * <p>
     * </ol>
     * </p>
     * <p>
     * </p>
     * </p>
     * <p>
     * <p>
     * </p>
     * <p>
     * It is still possible for the name to clash if two derived names
     * come out the same (as name comparison is done only to the
     * original names, not to the derived names). Such errors will
     * require renaming the property by changing either the property
     * name or the explicit name in the tagged value.
     * </p>
     * <p>
     * </p>
     * </p>
     */
    public abstract java.lang.String getUniqueName();

    /**
     * <p>
     * Get the SQL column name for the property. The SQL column name is
     * the unique name but with the explicit name taking precedence
     * over the property name. That is, if there is an explicit name,
     * that is the SQL column name, regardless of duplication, and
     * prefixing only occurs if there is no explicit name.
     * </p>
     * <p>
     * @see #getUniqueName
     * </p>
     */
    public abstract java.lang.String getSqlColumnName();

    /**
     * <p>
     * get the JDBC get call for this property based on the SQL column
     * name and the data type; this is something like
     * rs.getString(<col>) for a datatype::String property, for
     * example.
     * </p>
     */
    public abstract java.lang.String getJdbcGetCall();

    /**
     * <p>
     * get the proper JDBC set call given the SQL column name and the
     * data type; this might be stmt.setString(<index var>, <obj
     * var>.getter()) for a string, for example. Note that the
     * PreparedStatement object <strong>must</strong> be "stmt".
     * </p>
     */
    public abstract java.lang.String getJdbcSetCall();

    /**
     * <p>
     * Is the data type of this property suitable as a SQL primitive
     * data type?
     * </p>
     */
    public abstract boolean isSqlPrimitive();

    /**
     * <p>
     * Is the data type of this property a supported JDBC type? That
     * is, can you refer to this property in a persistent context (get,
     * set)? Use this flag to determine whether to generate JDBC
     * get/set code and SQL expressions involving the property.
     * </p>
     */
    public abstract boolean isSupportedJdbcType();

    /**
     * <p>
     * Get the property name expressed as a query name, the name of a
     * query of a collection of objects; valid only for collection
     * properties, otherwise it should be the same as the property
     * name. Also, the query name is init-capped.
     * </p>
     */
    public abstract java.lang.String getQueryName();

    /**
     * <p>
     * Get the getter name ("get" or "is" based on the data type and
     * query name of the accessor (relevant for collection getters)
     * </p>
     */
    public abstract java.lang.String getQueryGetterName();

    /**
     * <p>
     * the fully-qualified UML class name of the kind of object the
     * property represents; for a single-object property, the
     * fully-qualified class name is the same as the className member;
     * for a multiple-object property, this is the fully-qualifed class
     * name of the objects in the collection, not the type of the
     * collection itself
     * </p>
     */
    public abstract java.lang.String getObjectClassName();


}