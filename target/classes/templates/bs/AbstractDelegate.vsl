// license-header java merge-point
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDelegate.vsl

## The main data-transfer object (DTO)
#set ($dto = $class.transformToDto(null))
#set ($subsystem = $dto.subsystem)
#set ($businessPackageName = $subsystem.businessPackageName)
## used in catalog.xml for directory name
#set ($businessPackageDir = ${stringUtils.replace($businessPackageName, ".", "/")})
package ${businessPackageName};


#if (!$dto.readWrite)
import com.poesys.bs.delegate.AbstractReadOnlyDataDelegate;
#elseif ($dto.keyType == "IdentityKey")
import com.poesys.bs.delegate.AbstractIdentityDataDelegate;
#else
import com.poesys.bs.delegate.AbstractDataDelegate;
#end
import com.poesys.bs.delegate.DelegateException;
import com.poesys.db.connection.IConnectionFactory.DBMS;
#if ($dto.readWrite)
import com.poesys.db.dao.insert.IInsertSql;
import com.poesys.db.dao.update.IUpdateSql;
import com.poesys.db.dao.delete.IDeleteSql;
#end
import com.poesys.db.dao.query.IKeyQuerySql;
import com.poesys.db.dao.query.IQuerySql;


/**
 * <p>
 * A business delegate that provides an application programming interface for
 * ${dto.name} objects and their dependents. You should not modify this class;
 * instead, override or add methods in the class ${dto.name}Delegate, which
 * specializes this class.
 * </p>
${dto.documentation}
 * @see ${dto.name}Delegate
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class Abstract${dto.name}Delegate
#if (!$dto.readWrite)
    extends AbstractReadOnlyDataDelegate<Bs${dto.name}, ${dto.packageName}.I${dto.name}, ${dto.keyClass}> {
#elseif ($dto.keyType == "IdentityKey")
    extends AbstractIdentityDataDelegate<Bs${dto.name}, ${dto.packageName}.I${dto.name}, ${dto.keyClass}> {
#else
    extends AbstractDataDelegate<Bs${dto.name}, ${dto.packageName}.I${dto.name}, ${dto.keyClass}> {
#end
  /**
   * Create an Abstract${dto.name}Delegate object by supplying the database
   * subsystem in the database.properties file.
   * 
   * @param subsystem the database subsystem to use in database.properties
   */
  public Abstract${dto.name}Delegate(String subsystem) {
    super(subsystem, $dto.expiration);
  }

  /**
   * Create an Abstract${dto.name}Delegate object by supplying the database
   * subsystem in the database.properties file and a specific DBMS, usually
   * IConnectionFactory.DBMS.JNDI.
   * 
   * @param subsystem the database subsystem to use in database.properties
   * @param dbms the DBMS to use (usually IConnectionFactory.DBMS.JNDI)
   */
  public Abstract${dto.name}Delegate(String subsystem, DBMS dbms) {
    super(subsystem, dbms, $dto.expiration);
  }

  @Override
  protected String getClassName() {
    return ${dto.packageName}.${dto.name}.class.getName();
  }

#if ($dto.readWrite)
  @Override
  protected IInsertSql<${dto.packageName}.I${dto.name}> getInsertSql() {
    return new ${dto.packageName}.sql.Insert${dto.name}();
  }

  @Override
  protected IDeleteSql<${dto.packageName}.I${dto.name}> getDeleteSql() {
#if ($dto.removable)
    return new ${dto.packageName}.sql.Delete${dto.name}();
#else
    return null;
#end
  }

#if (!$dto.immutable)
  @Override
  protected IUpdateSql<${dto.packageName}.I${dto.name}> getUpdateSql() {
    return new ${dto.packageName}.sql.Update${dto.name}();
  }

#else
  @Override
  protected IUpdateSql<${dto.packageName}.I${dto.name}> getUpdateSql() {
    return null;
  }

#end
#end
  @Override
  protected IKeyQuerySql<${dto.packageName}.I${dto.name}> getQueryByKeySql() {
    return new ${dto.packageName}.sql.Query${dto.name}();
  }

  @Override
  protected IQuerySql<${dto.packageName}.I${dto.name}> getQueryListSql() {
    // Query-All method not required
    return new ${dto.packageName}.sql.QueryAll${dto.name}();
  }

  @Override
  protected ${businessPackageName}.Bs${dto.name} wrapData(${dto.packageName}.I${dto.name} dto) {
    return new ${businessPackageName}.Bs${dto.name}(dto);
  }

  /**
   * <p>
   * Create a new ${dto.name} with data fields.
   * </p>
#if ($dto.keyType.equals("SequenceKey"))
   * <p>
   * The ${dto.name} class has a sequence key; this method generates the
   * sequence for later insertion into the database.
   * </p>
#elseif ($dto.keyType.equals("IdentityKey"))
   * <p>
   * The ${dto.name} class has an identity key; this method does nothing with
   * respect to the key, which the database will generate when the new ${dto.name}
   * inserts into the database.
   * </p>
#elseif ($dto.keyType.equals("GuidKey"))
   * <p>
   * The ${dto.name} class has a globally unique identifier (GUID) key; this 
   * method generates the GUID for later insertion into the database.
   * </p>
#elseif ($dto.keyType.equals("NaturalKey"))
   * <p>
   * The ${dto.name} class has a natural key; this method creates the primary
   * key from the appropriate input properties.
   * </p>
#elseif ($dto.keyType.equals("None"))
   * <p>
   * The ${dto.name} class has no key of its own but inherits from a superclass
   * that has a ${dto.inheritedKeyType}. When you create an instance of this
   * class, the delegate creates a key of that type in the superclass.
   * </p>
#end
   * 
#foreach ($property in $dto.constructorArgs)
   * @param ${property.uniqueName} ${property.paramTag}
#end
   * @return the new ${dto.name} object
   * @throws DelegateException when there is a problem generating the key or
   *             creating the object
   */
#set ($sep = "")
  public ${businessPackageName}.Bs${dto.name} create${dto.name}(#foreach ($property in $dto.constructorArgs)${sep}${property.typeName} ${property.uniqueName}#set ($sep = ", ")#end)
      throws DelegateException {
## Build the right kind of key; not a Composite or Association key
#set ($keyType = $dto.keyType)
#if ($keyType.equals("None"))
#set ($keyType = $dto.inheritedKeyType)
#end
## Generated keys have only one key property, get its SQL column name and name.
#foreach($keyProperty in $dto.keyProperties)
#set ($keyCol = $keyProperty.sqlColumnName)
#set ($keyVar = $keyProperty.uniqueName)
#end
#if ($keyType.equals("SequenceKey"))
      com.poesys.db.pk.SequencePrimaryKey key = null;

    // Generate a new ${dto.name} id if the input key is null.
    if ($keyVar == null) {
      java.sql.Connection connection = null;
      try {
        connection = getConnection();
        if (connection == null) {
          throw new DelegateException("Could not get database connection to generate sequence");
        }
        
        if (dbms.equals(DBMS.MYSQL) || dbms.equals(DBMS.JNDI_MYSQL)) {
          key =
            com.poesys.db.pk.PrimaryKeyFactory.createMySqlSequenceKey(connection,
                                                                      "${dto.sequenceName}",
                                                                      "$keyCol",
                                                                      "${dto.packageName}.${dto.name}");
        } else if (dbms.equals(DBMS.ORACLE) || dbms.equals(DBMS.JNDI_ORACLE)) {
          // Create key with sequence ${dto.sequenceName}
          key =
            com.poesys.db.pk.PrimaryKeyFactory.createOracleSequenceKey(connection,
                                                                       "${dto.sequenceName}",
                                                                       "$keyCol",
                                                                       "${dto.packageName}.${dto.name}");
        } else {
          throw new DelegateException("com.poesys.bs.delegate.msg.noDbms");
        }
        // Get the sequence number for use as an attribute value.
        $keyVar = key.getValue();
      } catch (com.poesys.db.InvalidParametersException e) {
        Object[] args = e.getParameters().toArray();
        String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
        throw new DelegateException(message, e);
      } catch (com.poesys.db.NoPrimaryKeyException e) {
        Object[] args = e.getParameters().toArray();
        String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
        throw new DelegateException(message, e);
      } catch (java.sql.SQLException e) {
        throw new DelegateException(e.getMessage(), e);
      } finally {
        // Done with this connection, close it and return it to the pool.
        if (connection != null) {
          try {
            connection.close();
          } catch (java.sql.SQLException e) {
            throw new DelegateException(e.getMessage(), e);
          }
        }
      }
    } else {
      key = com.poesys.db.pk.PrimaryKeyFactory.createSequenceKey("$keyCol", $keyVar, "${dto.packageName}.${dto.name}");
    }

#elseif ($keyType.equals("GuidKey"))
      com.poesys.db.pk.GuidPrimaryKey key = null;

    // Generate a new ${dto.name} GUID if the input key is null.
    if ($keyVar == null) {
      try {
        // Get the GUID for use as an attribute value.
        key =
          com.poesys.db.pk.PrimaryKeyFactory.createGuidKey("$keyVar", "${dto.name}");
        $keyVar = java.util.UUID.fromString(key.getValue());
      } catch (com.poesys.db.InvalidParametersException e) {
        Object[] args = e.getParameters().toArray();
        String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
        throw new DelegateException(message, e);
      } catch (com.poesys.db.NoPrimaryKeyException e) {
        Object[] args = e.getParameters().toArray();
        String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
        throw new DelegateException(message, e);
      }
    }

#elseif ($keyType.equals("IdentityKey"))
## N.B. There is only one key column, so the foreach iterates exactly once.
    com.poesys.db.pk.IPrimaryKey key = 
      ${subsystem.fullyQualifiedName}.${subsystem.className}Factory.get${dto.name}PrimaryKey(#set($sep="")#foreach($key in $dto.keyProperties)${sep}${key.uniqueName}#set($sep=", ")#end);
      
#elseif ($keyType.equals("NaturalKey"))
    com.poesys.db.pk.NaturalPrimaryKey key = null;
    try {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($attr in $dto.keyProperties)
      list.add(new ${attr.pkColType}("${attr.sqlColumnName}", ${attr.uniqueName}));
#end
      key = 
        com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "${dto.packageName}.${dto.name}");
    } catch (com.poesys.db.InvalidParametersException e) {
      Object[] args = e.getParameters().toArray();
      String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
      throw new DelegateException(message, e);
    } catch (com.poesys.db.DuplicateKeyNameException e) {
      Object[] args = e.getParameters().toArray();
      String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
      throw new DelegateException(message, e);
    }

#elseif ($keyType.equals("CompositeKey"))
    // Create the composite key.
    com.poesys.db.pk.IPrimaryKey key = 
      ${subsystem.fullyQualifiedName}.${subsystem.className}Factory.get${dto.name}PrimaryKey(#set($sep="")#foreach($key in $dto.keyProperties)${sep}${key.uniqueName}#set($sep=", ")#end);
      
#end
#if ($dto.hasLazilyLoadedMember())
    // Create a data-access DTO proxy (supports lazy loading).
    ${dto.packageName}.I${dto.name} dto =
      new ${dto.packageName}.${dto.name}Proxy(new ${dto.packageName}.${dto.name}(key#foreach ($property in $dto.constructorArgs), ${property.uniqueName}#end));
#else
    // Create a data-access DTO for direct access, no proxy required.
    ${dto.packageName}.I${dto.name} dto =
      new ${dto.packageName}.${dto.name}(key#foreach ($property in $dto.constructorArgs), ${property.uniqueName}#end);
#end

    // Create the business DTO.
    return new ${dto.subsystem.businessPackageName}.Bs${dto.name}(dto);
  }

## -----------------------------------------------------------------------------
## Add a create method for each child class (composites and associations)
## -----------------------------------------------------------------------------
#foreach ($child in $dto.childDtos)
#set ($child = $property.dto)
#if ($child.keyType.equals("CompositeKey"))
  /**
   * Create a new ${child.name} child of ${dto.name} with a composite key.
   * 
   * @param parent the parent of the child object to create
#foreach ($property in $child.constructorArgs)
   * @param ${property.uniqueName} ${property.paramTag}
#end
   * @return a new ${child.name} business layer DTO
   * @throws DelegateException when a parameter causes a problem
   */
  public ${child.subsystem.businessPackageName}.Bs${child.name} create${child.name}(${businessPackageName}.Bs${dto.name} parent#foreach ($property in $child.constructorArgs), ${property.typeName} ${property.uniqueName}#end) throws DelegateException {
    // Create the key.
    com.poesys.db.pk.CompositePrimaryKey key = null;
    try {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($attr in $child.subKeyProperties)
      list.add(new ${attr.pkColType}("${attr.sqlColumnName}", ${attr.uniqueName}));
#end
## sub-key is never actually used to identify an object by itself, so the string
## passed in for class name could be anything; this implementation uses the name
## of the child class as the class name for the child sub-key.
	  com.poesys.db.pk.IPrimaryKey subKey = 
	    com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "${child.packageName}.${child.name}");
      key = 
        com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parent.getPrimaryKey(), 
                                                              subKey,
                                                              "${child.packageName}.${child.name}");
    } catch (com.poesys.db.InvalidParametersException e) {
      Object[] args = e.getParameters().toArray();
      String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
      throw new DelegateException(message, e);
    } catch (com.poesys.db.DuplicateKeyNameException e) {
      Object[] args = e.getParameters().toArray();
      String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
      throw new DelegateException(message, e);
    }

#if ($child.hasLazilyLoadedMember())
    // Create a composite-key child data-access ${child.name} DTO proxy (supports lazy loading).
    ${child.packageName}.I${child.name} dto =
      new ${child.packageName}.${child.name}Proxy(new ${child.packageName}.${child.name}(key#foreach ($key in $child.associatedKeys), ${key.name}Object.toDto()#end#foreach ($attr in $child.constructorArgs), ${attr.uniqueName}#end));
#else
    // Create a composite-key child data-access ${child.name} DTO for direct access, no proxy required.
    ${child.packageName}.I${child.name} dto =
      new ${child.packageName}.${child.name}(key#foreach ($key in $child.associatedKeys), ${key.name}Object.toDto()#end#foreach ($attr in $child.constructorArgs), ${attr.uniqueName}#end);
#end

    // Create the business DTO.
    return new ${child.subsystem.businessPackageName}.Bs${child.name}(dto);
  }
#elseif ($child.keyType.equals("AssociationKey"))
## Many-to-many or other association object
  /**
   * Create a new ${child.name} association class child of ${dto.name} with 
   * an association key. This class links the input objects.
   * 
## Add "Object" to distinguish n-ary keys from foreign key attributes.
#foreach ($key in $child.associatedKeys)
   * @param ${key.name}Object associated ${key.typeName} object (part of the key)
#end
#foreach ($property in $child.constructorArgs)
   * @param ${property.uniqueName} ${property.paramTag}
#end
   * @return a new ${child.name} business layer DTO
   * @throws DelegateException when a parameter causes a problem
   */
#set ($sep="")
## Add "Object" to distinguish n-ary objects from foreign key attributes.
  public ${child.subsystem.businessPackageName}.Bs${child.name} create${child.name}(#foreach ($key in $child.associatedKeys)$sep${key.businessPackageName}.Bs${key.typeName} ${key.name}Object#set ($sep=", ")#end#foreach ($property in $child.constructorArgs)${sep}${property.typeName} ${property.uniqueName}#set ($sep=", ")#end) throws DelegateException {
    // Create the key.
    com.poesys.db.pk.AssociationPrimaryKey key = null;
    try {
      java.util.ArrayList<com.poesys.db.pk.IPrimaryKey> list =
        new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
## Add "Object" to distinguish n-ary keys from foreign key attributes.
#foreach ($key in $child.associatedKeys)
      list.add(${key.name}Object.getPrimaryKey());
#end
      key = 
        com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "${child.packageName}.${child.name}");
    } catch (com.poesys.db.InvalidParametersException e) {
      Object[] args = e.getParameters().toArray();
      String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
      throw new DelegateException(message, e);
    } catch (com.poesys.db.DuplicateKeyNameException e) {
      Object[] args = e.getParameters().toArray();
      String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
      throw new DelegateException(message, e);
    }

#if ($child.hasLazilyLoadedMember())
    // Create an association-key child data-access ${child.name} DTO proxy (supports lazy loading).
    ${child.packageName}.I${child.name} dto =
      new ${child.packageName}.${child.name}Proxy(new ${child.packageName}.${child.name}(key#foreach ($key in $child.associatedKeys), ${key.name}Object.toDto()#end#foreach ($attr in $child.constructorArgs), ${attr.uniqueName}#end));
#else
    // Create an association-key child data-access ${child.name} DTO for direct access, no proxy required.
    ${child.packageName}.I${child.name} dto =
      new ${child.packageName}.${child.name}(key#foreach ($key in $child.associatedKeys), ${key.name}Object.toDto()#end#foreach ($attr in $child.constructorArgs), ${attr.uniqueName}#end);
#end

    // Create the business DTO.
    return new ${child.subsystem.businessPackageName}.Bs${child.name}(dto);
  }
#end
#end
#if ($dto.readWrite)
## -----------------------------------------------------------------------------
## If there are superclasses (inheritance), override the insert and process
## methods to provide a series of inserts into the superclasses rather than just
## using the default insert into the leaf class.
## -----------------------------------------------------------------------------
#if ($dto.superclasses.size() > 0)

  @Override
  public void insert(java.util.List<Bs${dto.name}> list) throws DelegateException {
    java.sql.Connection c = getConnection();
    
    // Create superclass inserters.
    
#foreach ($super in $dto.superclasses)
    // ${super.name}
    final com.poesys.db.dao.IDaoFactory<${super.packageName}.I${super.name}> ${super.nameAsProperty}Factory =
      manager.getFactory("${super.packageName}.${super.name}", "${super.subsystem.fullyQualifiedName}", ${super.expiration});
    // Key type: ${super.keyType}, Inherited Key type: $super.inheritedKeyType
#if ($super.keyType == "IdentityKey" || $super.inheritedKeyType == "IdentityKey")
    com.poesys.db.dao.insert.IInsertCollection<${super.packageName}.I${super.name}> ${super.nameAsProperty}Inserter =
      ${super.nameAsProperty}Factory.getInsertCollection(new ${super.packageName}.sql.Insert${super.name}(), false);
#else
    com.poesys.db.dao.insert.IInsertBatch<${super.packageName}.I${super.name}> ${super.nameAsProperty}Inserter =
      ${super.nameAsProperty}Factory.getInsertBatch(new ${super.packageName}.sql.Insert${super.name}());
#end
    java.util.Collection<${super.packageName}.I${super.name}> ${super.nameAsProperty}Dtos = convertDtoList(list);
    
#end
    // ${dto.name} (uses standard class factory from AbstractDataDelegate) $dto.keyType $dto.inheritedKeyType
#if ($dto.keyType == "IdentityKey" || $dto.inheritedKeyType == "IdentityKey")
    com.poesys.db.dao.insert.IInsertCollection<${dto.packageName}.I${dto.name}> ${dto.nameAsProperty}Inserter =
      factory.getInsertCollection(getInsertSql(), false);
#else
    com.poesys.db.dao.insert.IInsertBatch<${dto.packageName}.I${dto.name}> ${dto.nameAsProperty}Inserter =
      factory.getInsertBatch(getInsertSql());
#end
    java.util.Collection<${dto.packageName}.I${dto.name}> ${dto.nameAsProperty}Dtos = convertDtoList(list);

    try {
      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set 
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      for (com.poesys.db.dto.IDbDto dto : ${dto.nameAsProperty}Dtos) {
        dto.setSuppressNestedInserts(true);
        dto.setSuppressNestedPreInserts(false);
      }
#set ($first = true)
#set ($second = false)
#foreach ($super in $dto.superclasses)
#if ($second)
      // Set pre-insert suppression on to suppress inserts in anything but root.
      for (com.poesys.db.dto.IDbDto dto : ${dto.nameAsProperty}Dtos) {
        dto.setSuppressNestedPreInserts(true);
      }
#set ($second = false)
#else
#if ($first)
#set ($first = false)
#set ($second = true)
#end
#end
#if ($super.keyType == "IdentityKey" || $super.inheritedKeyType == "IdentityKey")
      ${super.nameAsProperty}Inserter.insert(c, ${super.nameAsProperty}Dtos);
#else
      ${super.nameAsProperty}Inserter.insert(c, ${super.nameAsProperty}Dtos, ${super.nameAsProperty}Dtos.size() / 2);
#end
#end
      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : ${dto.nameAsProperty}Dtos) {
        dto.setSuppressNestedInserts(false);
      }
      // Mark the DAO as a leaf DAO.
      ${dto.nameAsProperty}Inserter.setLeaf(true);
#if ($dto.keyType == "IdentityKey" || $dto.inheritedKeyType == "IdentityKey")
      ${dto.nameAsProperty}Inserter.insert(c, ${dto.nameAsProperty}Dtos);
#else
      ${dto.nameAsProperty}Inserter.insert(c, ${dto.nameAsProperty}Dtos, ${dto.nameAsProperty}Dtos.size() / 2);
#end
      
    } catch (com.poesys.db.ConstraintViolationException e) {
      rollBack(c, e.getMessage(), e);
    } catch (java.sql.SQLException e) {
      rollBack(c, e.getMessage(), e);
    } catch (com.poesys.db.BatchException e) {
      // Don't roll back the whole transaction; the DBMS rolls back the
      // individual inserts that failed, but the rest should be committed.
      String message = com.poesys.db.Message.getMessage(e.getMessage(), null);
      throw new DelegateException(message, e);
    } catch (com.poesys.db.dto.DtoStatusException e) {
      rollBack(c, e.getMessage(), e);
    } finally {
      commit(c);
      close(c);
      finalizeStatus(${dto.nameAsProperty}Dtos, com.poesys.db.dto.IDbDto.Status.EXISTING);
    }
  }

  @Override
  public void process(java.util.List<Bs${dto.name}> list) throws DelegateException {
    java.sql.Connection c = getConnection();

    // Create the 3 DAOs for inserting, updating, and deleting the concrete object.
    com.poesys.db.dao.insert.IInsertBatch<${dto.packageName}.I${dto.name}> inserter = 
      factory.getInsertBatch(getInsertSql());
    com.poesys.db.dao.update.IUpdateBatch<${dto.packageName}.I${dto.name}> updater = 
      factory.getUpdateBatch(getUpdateSql());
#if ($dto.superclasses.size() == 0)
    com.poesys.db.dao.delete.IDeleteBatch<${dto.packageName}.I${dto.name}> deleter = 
      factory.getDeleteBatch(getDeleteSql());
#end
    java.util.Collection<${dto.packageName}.I${dto.name}> dtos = convertDtoList(list);

    // Create the DAOs for inserting or updating the superclasses.
    try {
#set ($root=true)
#foreach ($super in $dto.superclasses)
      // ${super.name}
      final com.poesys.db.dao.IDaoFactory<${super.packageName}.I${super.name}> ${super.nameAsProperty}Factory =
        manager.getFactory("${super.packageName}.${super.name}", "${super.packageName}.${super.name}", ${super.expiration});
      com.poesys.db.dao.insert.IInsertBatch<${super.packageName}.I${super.name}> ${super.nameAsProperty}Inserter =
        ${super.nameAsProperty}Factory.getInsertBatch(new ${super.packageName}.sql.Insert${super.name}());
      com.poesys.db.dao.update.IUpdateBatch<${super.packageName}.I${super.name}> ${super.nameAsProperty}Updater =
        ${super.nameAsProperty}Factory.getUpdateBatch(new ${super.packageName}.sql.Update${super.name}());
      java.util.Collection<${super.packageName}.I${super.name}> ${super.nameAsProperty}Dtos = convertDtoList(list);
#if ($root)
      // If there is a root superclass, create a deleter for the root class.
      // The delete will cascade through foreign key constraints.
      com.poesys.db.dao.delete.IDeleteBatch<${super.packageName}.I${super.name}> deleter = 
        ${super.nameAsProperty}Factory.getDeleteBatch(new ${super.packageName}.sql.Delete${super.name}());
      if (deleter != null) {
        deleter.delete(c, ${super.nameAsProperty}Dtos, ${super.nameAsProperty}Dtos.size()/2);
      }
#set ($root=false)
#end
    
#end
#if ($dto.superclasses.size() == 0)

      if (deleter != null) {
        deleter.delete(c, dtos, dtos.size() / 2);
      }

#end
      // Insert or update the superclass objects from the root down after 
      // turning off nested inserts.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(true);
        dto.setSuppressNestedPreInserts(false);
      }
#set ($first = true)
#set ($second = false)
#foreach ($super in $dto.superclasses)
#if ($second)
      // Set pre-insert suppression on to suppress inserts in anything but root.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedPreInserts(true);
      }
#set ($second = false)
#else
#if ($first)
#set ($first = false)
#set ($second = true)
#end
#end
      // Process any inserts for $super.nameAsProperty.
      if (${super.nameAsProperty}Inserter != null) {
        ${super.nameAsProperty}Inserter.insert(c, ${super.nameAsProperty}Dtos, ${super.nameAsProperty}Dtos.size() / 2);
      }

      // Process any updates for $super.nameAsProperty.
      if (${super.nameAsProperty}Updater != null) {
        ${super.nameAsProperty}Updater.update(c, ${super.nameAsProperty}Dtos, ${super.nameAsProperty}Dtos.size() / 2);
      }
#end
      
      // Insert the leaf object after resetting the nested object insertion to
      // insert any nested objects connecting to any of the inserted classes.
      if (inserter != null) {
        for (com.poesys.db.dto.IDbDto dto : dtos) {
          dto.setSuppressNestedInserts(false);
        }
        inserter.setLeaf(true);
        inserter.insert(c, dtos, dtos.size() / 2);
      }
      
      // Update the object.
      if (updater != null) {
        updater.setLeaf(true);
        updater.update(c, dtos, dtos.size() / 2);
      }
    } catch (com.poesys.db.ConstraintViolationException e) {
      rollBack(c, e.getMessage(), e);
    } catch (java.sql.SQLException e) {
      rollBack(c, e.getMessage(), e);
    } catch (com.poesys.db.BatchException e) {
      // Don't roll back the whole transaction; the DBMS rolls back the
      // individual operations that failed, but the rest should be committed.
      String message = com.poesys.db.Message.getMessage(e.getMessage(), null);
      throw new DelegateException(message, e);
    } catch (com.poesys.db.dto.DtoStatusException e) {
      String message = com.poesys.db.Message.getMessage(e.getMessage(), null);
      rollBack(c, message, e);
    } finally {
      commit(c);
      close(c);
      updateChangedToExisting(dtos);
      finalizeStatus(dtos, com.poesys.db.dto.IDbDto.Status.EXISTING);
      finalizeStatus(dtos, com.poesys.db.dto.IDbDto.Status.DELETED);
    }
  }
#end
#if ($dto.childDtos.size() > 0)

  @Override
  public void truncateTable(String tableName) throws DelegateException {
    java.sql.Connection c = getConnection();
    com.poesys.db.dao.ddl.ISql sql = null;
    com.poesys.db.dao.ddl.IExecuteSql executive = null;

    // First truncate any child tables.
#foreach ($child in $dto.childDtos)
    sql = new com.poesys.db.dao.ddl.TruncateTableSql("${child.sqlTableName}");
    executive = new com.poesys.db.dao.ddl.ExecuteSql(sql);
    try {
      executive.execute(c);
    } catch (java.sql.SQLException e) {
      throw new DelegateException(e.getMessage() + ": " + "${child.sqlTableName}", e);
    }

#end
    // Now truncate the current table.
    sql = new com.poesys.db.dao.ddl.TruncateTableSql(tableName);
    executive = new com.poesys.db.dao.ddl.ExecuteSql(sql);
    try {
      executive.execute(c);
    } catch (java.sql.SQLException e) {
      throw new DelegateException(e.getMessage() + ": " + "${dto.sqlTableName}", e);
    }
  }
#end
#end
}
