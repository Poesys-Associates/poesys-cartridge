// license-header java merge-point
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractBsDto.vsl

## The main data-transfer object (DTO)
#set ($dto = $class.transformToDto(null))
#set ($subsystem = $dto.subsystem)
## Type and function name strings for List and Collection types
#set ($listType = "java.util.List")
#set ($listString = "List")
#set ($collType = "java.util.Collection")
#set ($collString = "Collection")

package ${subsystem.businessPackageName};

## used in catalog.xml for directory name
#set ($businessPackageDir = ${stringUtils.replace($subsystem.businessPackageName, ".", "/")})

import com.poesys.bs.delegate.DelegateException;
import com.poesys.bs.dto.IDto;
import com.poesys.db.dto.DtoStatusException;
import com.poesys.db.pk.IPrimaryKey;
import com.poesys.bs.dto.AbstractDto;


import ${dto.packageName}.I${dto.name};
#if (!$dto.abstractClass)
import ${dto.packageName}.${dto.name}Proxy;
import ${dto.packageName}.${dto.name};
#end


/**
 * <p>
 * A business layer data-transfer object (DTO) for the ${dto.name}. This class
 * is an abstract class that contains AndroMDA generated code; change nothing
 * in this class. Instead, override any methods in the concrete subclass
 * generated in the same package. AndroMDA will overwrite this class each time
 * you run it but will never overwrite the concrete subclass.
 * </p>
${dto.documentation}
 * <p>
 * Stereotypes:
 * </p>
 * <ul>
#foreach ($name in $dto.stereotypeNames)
 *     <li>$name</li>
#end
 * </ul>
 * <p>
 * Class is read/write: ${dto.readWrite}
 * </p>
 *
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractBs${dto.name} 
    extends AbstractDto<${dto.packageName}.I${dto.name}> {
#foreach ($property in $dto.inheritedProperties)
#if ($property.toMany)
#set ($propertyName = ${stringUtils.uncapitalize(${property.queryName})})
#set ($className = ${property.queryName})
#else
#set ($propertyName = ${propery.uniqueName})
#set ($className = ${stringUtils.capitalize(${property.uniqueName})})
#end
#set ($bsPackage = $property.dto.subsystem.businessPackageName)
#if ($property.associationEnd && $property.toMany)
#if ($property.ordered)
#set ($collectionType = $listString)
#set ($fullCollectionType = $listType)
#else
#set ($collectionType = $collString)
#set ($fullCollectionType = $collType)
#end

  /**
   * A ${collectionType} builder helper class for building a business-layer ${collectionType} 
   * of Bs${property.dto.name} objects from an inherited ${collectionType} ${propertyName} of data-access-layer 
   * ${property.className} objects
   */
  private class Bs${className}${collectionType}Builder 
      extends com.poesys.bs.dto.${collectionType}Builder<${property.className}, ${bsPackage}.Bs${property.dto.name}> {
    @Override
    public ${bsPackage}.Bs${property.dto.name} get(${property.className} dto) {
      return new ${bsPackage}.Bs${property.dto.name}(dto);
    }
  }
## Only need second helper class if the class is immutable, as the helper is
## only used in setters.
#if (!$dto.immutable && !$property.immutable)

  /**
   * A ${collectionType} builder helper class for building a data-access-layer ${collectionType} 
   * of ${property.dto.name} objects from an input ${collectionType} ${propertyName} of 
   * business-layer Bs${property.dto.name} objects
   */
  private class ${className}${collectionType}Builder 
      extends com.poesys.bs.dto.${collectionType}Builder<${bsPackage}.Bs${property.dto.name}, ${property.className}> {
    @Override
    public ${property.className} get(${bsPackage}.Bs${property.dto.name} dto) {
      return dto.toDto();
    }
  }
#end
#end
#end
#foreach ($property in $dto.collectionProperties)
#if ($property.toMany)
#set ($propertyName = ${stringUtils.uncapitalize(${property.queryName})})
#set ($className = ${property.queryName})
#else
#set ($propertyName = ${propery.uniqueName})
#set ($className = ${stringUtils.capitalize(${property.uniqueName})})
#end
#set ($bsPackage = $property.dto.subsystem.businessPackageName)
#if ($property.ordered)
#set ($collectionType = $listString)
#else
#set ($collectionType = $collString)
#end

  /**
   * A ${collectionType} builder helper class for building a business-layer ${collectionType} 
   * of Bs${property.dto.name} objects from a ${collectionType} ${propertyName} of data-access-layer 
   * ${property.className} objects
   */
  private class Bs${className}${collectionType}Builder 
      extends com.poesys.bs.dto.${collectionType}Builder<${property.className}, ${bsPackage}.Bs${property.dto.name}> {
    @Override
    public ${bsPackage}.Bs${property.dto.name} get(${property.className} dto) {
      return new ${bsPackage}.Bs${property.dto.name}(dto);
    }
  }
## Only need second helper class if the class is immutable, as the helper is
## only used in setters.
#if (!$dto.immutable && !$property.immutable)

  /**
   * A ${collectionType} builder helper class for building a data-access-layer ${collectionType} 
   * of ${property.dto.name} objects from an input ${collectionType} ${propertyName} of 
   * business-layer Bs${property.dto.name} objects
   */
  private class ${className}${collectionType}Builder 
      extends com.poesys.bs.dto.${collectionType}Builder<${bsPackage}.Bs${property.dto.name}, ${property.className}> {
    @Override
    public ${property.className} get(${bsPackage}.Bs${property.dto.name} dto) {
      return dto.toDto();
    }
  }
#end
#end

  /**
   * Create a Bs${dto.name} object from a ${dto.name} object.
   * 
   * @param dto the data-access layer ${dto.name} DTO
   * @throws DelegateException when there is a problem creating the ${dto.name}
   */
  public AbstractBs${dto.name}(I${dto.name} dto) throws DelegateException {
    super(dto);
  }

#if (!$dto.abstractClass)
  /**
   * Create a ${dto.name} from new data.
   *
   * @param key the primary key of the ${dto.name}
#foreach ($key in $dto.associatedKeys)
   * @param ${key.name}Object associated $key.typeName object
#end
#foreach ($property in $dto.constructorArgs)
   * @param ${property.uniqueName} ${property.paramTag}
#end
   */
  public AbstractBs${dto.name}(IPrimaryKey key#foreach ($key in $dto.associatedKeys), ${key.packageName}.I${key.typeName} ${key.name}Object#end#foreach ($property in $dto.constructorArgs), ${property.typeName} ${property.uniqueName}#end) {
    super(new ${dto.name}Proxy(new ${dto.name}(key#foreach ($key in $dto.associatedKeys), ${key.name}Object#end#foreach ($property in $dto.constructorArgs), ${property.uniqueName}#end)));
  }

#end
  @SuppressWarnings("unchecked")
  @Override
  public boolean equals(Object arg0) {
    // Unchecked cast here
    IDto<I${dto.name}> other = (IDto<I${dto.name}>)arg0;
    return dto.equals(other.toDto());
  }

  @Override
  public int hashCode() {
    return dto.hashCode();
  }

  public int compareTo(IDto<I${dto.name}> o) {
    return dto.compareTo(o.toDto());
  }

  public void markChildrenDeleted() throws DtoStatusException {
    dto.markChildrenDeleted();
  }
  
  public IPrimaryKey getPrimaryKey() {
    return dto.getPrimaryKey();
  }
## Generate wrapper methods for inherited data members
#if ($dto.inheritedProperties.size() > 0)

  // Inherited properties
#end
#foreach ($property in $dto.inheritedProperties)
#set ($cappedName = ${stringUtils.capitalize($property.uniqueName)})
#if ($property.toMany)
## Multiple object collection or list, use list builder to convert list of objects
#if ($property.ordered)
#set ($collectionType = $listString)
#set ($fullCollectionType = $listType)
#else
#set ($collectionType = $collString)
#set ($fullCollectionType = $collType)
#end
#end

  /**
${property.getDocumentation()}
   * <p>
   * Added by ${property.source} through inheritance
#if ($property.lazy)
   * </p>
   * <p>
   * This property loads lazily on demand rather than when you first query the 
   * I${dto.name} object.
#end
   * </p>
   * <ul>
   * <li>Property is read/write: ${property.readWrite}</li>
   * <li>Property is inherited from a superclass</li>
   * </ul>
#if ($property.toMany)
   * @return a $collectionType of I${property.dto.name} ${property.uniqueName}
#else
   * @return a ${property.typeName} ${property.uniqueName}
#end
#if ($property.lazy)
   * @throws java.sql.SQLException when the method can't get a SQL connection to 
   *                               load the property lazily
#end
   */
#if ($property.toMany)
  ${property.visibility} ${fullCollectionType}<${property.dto.subsystem.businessPackageName}.Bs${property.dto.name}> ${property.getterName}() #if ($property.lazy)throws java.sql.SQLException #end{
    Bs${property.queryName}${collectionType}Builder builder = new Bs${property.queryName}${collectionType}Builder();
    return builder.get${collectionType}(dto.${property.queryGetterName}());
#else
#if ($property.supportedJdbcType)
## Single, persistent object, just wrap DB DTO into BS DTO

  ${property.visibility} ${property.bsTypeName} ${property.getterName}() #if ($property.lazy)throws java.sql.SQLException #end{
#if ($property.associationEnd && $property.required)
    // Return 1
    return new ${property.bsTypeName}(dto.${property.getterName}());
#elseif ($property.associationEnd)
## Can be null, so check before creating a new business object.
    ${property.bsTypeName} bsObject = null;
    ${property.typeName} object = dto.${property.getterName}();
#if ($property.typeName != $property.bsTypeName)
	if (object != null) {
	  bsObject = new ${property.bsTypeName}(object);
	}
#else
    bsObject = object;
#end
	return bsObject;
#else
    return dto.${property.getterName}();
#end
#else
## Single, transient object, just return data directly as a business object.
  ${property.visibility} ${property.bsTypeName} ${property.getterName}() #if ($property.lazy)throws java.sql.SQLException #end{
## If the BS and DB type names are the same, this is a transient type, so
## just output it directly; otherwise, wrap the DB object in a new BS object.
#if(${property.bsTypeName} == ${property.typeName})
    return dto.${property.getterName}();
#elseif ($property.required)
## Required property, no need for null check here
    // Return 2
    return new ${property.bsTypeName}(dto.${property.getterName}());
#else
## Can be null, so check before creating a new business object.
    ${property.bsTypeName} bsObject = null;
    ${property.typeName} object = dto.${property.getterName}();
#if ($property.typeName != $property.bsTypeName)
	if (object != null) {
	  bsObject = new ${property.bsTypeName}(object);
	}
#else
    bsObject = object;
#end
	return bsObject;
#end
#end
#end
  }
## Only output a setter if the DTO and property are read/write and mutable.
// Setter here if the four conditions below are all true or not false
// Read/Write DTO: ${dto.readWrite}
// Mutable DTO: not ${dto.immutable}
// Mutable property: not ${property.immutable}
// Read/Write property: ${property.readWrite}
#if (${dto.readWrite} && !${dto.immutable} && !${property.immutable} && ${property.readWrite})

  /**
   * <p>
   * Set the ${property.uniqueName}.
   * </p>
${property.getDocumentation()}
   * <p>
   * Added by ${property.source}
   * </p>
   * <ul>
   * <li>Property is read/write: ${property.readWrite}</li>
   * <li>Property is inherited from a superclass</li>
   * </ul>
#if ($property.toMany)
   * @param ${stringUtils.uncapitalize(${property.queryName})} the value to set into the object
#else
   * @param ${property.uniqueName} the value to set into the object
#end
   * @throws com.poesys.db.dto.DtoStatusException when the system can't set
   *                 the data-access status to CHANGED
#if ($property.required)
   * @throws com.poesys.db.InvalidParametersException when the property is
   *                 required but the input parameter ${property.uniqueName} is null
#end
   */
#if ($property.toMany)
## Multiple object collection or list, use list builder to convert list of objects
  ${property.visibility} void ${property.setterName}(${fullCollectionType}<${property.bsTypeName}> ${stringUtils.uncapitalize(${property.queryName})}) 
      throws com.poesys.db.dto.DtoStatusException#if (${property.required}), com.poesys.db.InvalidParametersException #end{
    ${property.queryName}${collectionType}Builder builder = new ${property.queryName}${collectionType}Builder();
      dto.${property.setterName}(builder.get${collectionType}(${stringUtils.uncapitalize(${property.queryName})}));
#else
## Single object, just pass through to DB DTO
  ${property.visibility} void ${property.setterName}(${property.bsTypeName} ${property.uniqueName}) 
      throws com.poesys.db.dto.DtoStatusException#if (${property.required}), com.poesys.db.InvalidParametersException #end{
#if ($property.associationEnd)
    dto.${property.setterName}(${property.uniqueName} == null ? null : ${property.uniqueName}.toDto());
#else
    dto.${property.setterName}(${property.uniqueName});
#end
#end
  }
#end
#end
## Generate access methods for data members (local and association properties)
#if ($dto.dataMembers.size() > 0)

  // Data member properties
#end
#foreach ($property in $dto.dataMembers)
#if ($property.toMany)
#set ($propertyName = ${$stringUtils.uncapitalize(${property.queryName})})
#set ($className = $property.queryName)
#set ($getterName = $property.queryGetterName)
#else
#set ($propertyName = $property.uniqueName)
#set ($className = ${$stringUtils.capitalize(${property.uniqueName})})
#set ($getterName = $property.getterName)
#end

  /**
${property.getDocumentation()}
   * <p>
   * Added by ${property.source} as data member
#if ($property.lazy)
   * </p>
   * <p>
   * This property loads lazily on demand the first time you call this method,
   * not when you instantiate the Bs${dto.name} object.
#end
   * </p>
   * <ul>
   * <li>Property is read/write: ${property.readWrite}</li>
   * <li>Property is defined in the data-access object ${dto.name}</li>
   * </ul>
   * @return a ${property.bsTypeName} ${propertyName}
#if ($property.lazy)
   * @throws java.sql.SQLException when the method can't get a SQL connection to 
   *                               load the property lazily
#end
   */
#if ($property.toMany)
## Multiple object collection or list, use list builder to convert list of objects
#if ($property.ordered)
#set ($collectionType = $listString)
#set ($fullCollectionType = $listType)
#else
#set ($collectionType = $collString)
#set ($fullCollectionType = $collType)
#end
  ${property.visibility} ${fullCollectionType}<${property.bsTypeName}> ${getterName}() #if ($property.lazy)throws java.sql.SQLException #end{
    Bs${className}${collectionType}Builder builder = new Bs${className}${collectionType}Builder();
    return builder.get${collectionType}(dto.${getterName}());
#else
#if ($property.sqlPrimitive)
## Single, persistent object, just pass through to DB DTO
  ${property.visibility} ${property.bsTypeName} ${getterName}() #if ($property.lazy)throws java.sql.SQLException #end{
#if ($property.associationEnd && $property.required)
    // Return 3
#if ($property.typeName != $property.bsTypeName)
    return new ${property.bsTypeName}(dto.${getterName}());
#else
    return dto.${getterName}();
#end
#elseif ($property.associationEnd)
## Can be null, so check before creating a new business object.
    ${property.bsTypeName} bsObject = null;
    ${property.typeName} object = dto.${getterName}();
#if ($property.typeName != $property.bsTypeName)
	if (object != null) {
	  bsObject = new ${property.bsTypeName}(object);
	}
#else
    bsObject = object;
#end
	return bsObject;
#else
    return dto.${getterName}();
#end
#else
## Single, transient object, just return the object.
  ${property.visibility} ${property.bsTypeName} ${getterName}() #if ($property.lazy)throws java.sql.SQLException #end{
## If the BS and DB type names are the same, this is a transient type, so
## just output it directly; otherwise, wrap the DB object in a new BS object.
#if(${property.bsTypeName} == ${property.typeName})
    return dto.${getterName}();
#elseif (!$property.required)
## Can be null, so check before creating a new business object.
    ${property.bsTypeName} bsObject = null;
    ${property.typeName} object = dto.${getterName}();
#if ($property.typeName != $property.bsTypeName)
	if (object != null) {
	  bsObject = new ${property.bsTypeName}(object);
	}
#else
    bsObject = object;
#end
	return bsObject;
#else
    // Return 4
    return new ${property.bsTypeName}(dto.${getterName}());
#end
#end
#end
  }
## Only output a setter if the DTO and property are read/write and mutable.
#if (${dto.readWrite} && !${dto.immutable} && !${property.immutable} && ${property.readWrite})

  /**
   * <p>
   * Set the ${property.uniqueName}.
   * </p>
${property.getDocumentation()}
   * <p>
   * Added by ${property.source}
   * </p>
   * <ul>
   * <li>Property is read/write: ${property.readWrite}</li>
   * <li>Property is defined in the data-access object ${dto.name}</li>
   * </ul>
   * @param ${propertyName} the associated business object
   * @throws com.poesys.db.dto.DtoStatusException when the system can't set
   *                 the data-access status to CHANGED
#if ($property.required)
   * @throws com.poesys.db.InvalidParametersException when the property is
   *                 required but the input parameter ${propertyName} is null
#end
   */
#if ($property.toMany)
## Multiple object collection or list, use list builder to convert list of objects
#if ($property.ordered)
#set ($collectionType = $listString)
#set ($fullCollectionType = $listType)
#else
#set ($collectionType = $collString)
#set ($fullCollectionType = $collType)
#end
  ${property.visibility} void ${property.setterName}(${fullCollectionType}<${property.bsTypeName}> ${propertyName}) 
      throws com.poesys.db.dto.DtoStatusException#if (${property.required}), com.poesys.db.InvalidParametersException #end{
    ${className}${collectionType}Builder builder = new ${className}${collectionType}Builder();
      dto.${property.setterName}(builder.get${collectionType}(${propertyName}));
#else
#if ($property.supportedJdbcType || $property.typeName != $property.bsTypeName)
## Single, persistent object, just pass through to DB DTO
## supportedJdbcType indicates it's a primitive; different bs name means its a persistent object
  ${property.visibility} void ${property.setterName}(${property.bsTypeName} ${propertyName}) 
      throws com.poesys.db.dto.DtoStatusException #if (${property.required}), com.poesys.db.InvalidParametersException #end{
#else
## Single, transient object, just pass through to DB DTO
  ${property.visibility} void ${property.setterName}(${property.typeName} ${propertyName}) 
      throws com.poesys.db.dto.DtoStatusException #if (${property.required}), com.poesys.db.InvalidParametersException #end{
#end
#if ($property.associationEnd && ($property.supportedJdbcType || $property.typeName != $property.bsTypeName))
    dto.${property.setterName}(${propertyName} == null ? null : ${propertyName}.toDto());
#else
    dto.${property.setterName}(${propertyName});
#end
#end
  }
#end
#end
## Add() method for each nested collection
## Only have add() methods for read/write, mutable DTOs
#if (${dto.readWrite} && !${dto.immutable})
#foreach ($property in $dto.collectionProperties)
#set ($propertyName = ${stringUtils.uncapitalize(${property.queryName})})
## Only read/write and immutable properties can have add methods.
#if (${property.readWrite} && !${property.immutable})

  /**
   * Add a ${property.dto.name} object to the ${propertyName} collection.
   *
   * @param object the object to add to the collection
#if ($property.lazy)
   * @throws java.sql.SQLException when the method can't get a SQL connection to 
   *                               load the property lazily
#end
   */
  ${property.visibility} void add${property.queryName}${property.dto.name}(${property.bsTypeName} object)#if ($property.lazy) throws java.sql.SQLException#end {
    dto.add${property.queryName}${property.dto.name}(object.toDto());
  }
#end
#end
#end
}