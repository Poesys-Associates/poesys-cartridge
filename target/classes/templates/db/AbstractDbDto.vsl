// license-header java merge-point
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDbDto.vsl

## The main data-access data-transfer object (DTO)
#set ($dto = $class.transformToDto(null))
## Whether the objects of the class can change
package ${dto.packageName};


import org.apache.log4j.Logger;

import com.poesys.db.pk.IPrimaryKey;

#if (!${dto.superclass})
import com.poesys.db.dto.AbstractDto;
import com.poesys.db.dto.DtoStatusException;


#end
/**
 * <p>
 * A data-access layer data-transfer object for the ${dto.name}. This class
 * is an abstract class that contains AndroMDA generated code; change nothing
 * in this class. Instead, override any methods in the concrete subclass
 * generated in the same package. AndroMDA will overwrite this class each time
 * you run it but will never overwrite the concrete subclass.
 * </p>
${dto.documentation}
 * <p>
 * Stereotypes:
 * </p>
 * <ul>
#foreach ($name in $dto.stereotypeNames)
 *     <li>$name</li>
#end
 * </ul>
 * <p>
 * Class is read/write: ${dto.readWrite}
 * </p>
 *
 * @author Poesys/DB Cartridge
 */
public abstract class Abstract${dto.name} extends#if (${dto.superclass}) ${dto.superpackage}.${dto.superclass}#else AbstractDto#end implements I${dto.name} {
  /** Default serial version UID for the Serializable DTO */
  private static final long serialVersionUID = 1L;

  /** Logger for this class */
  private static final Logger logger = Logger.getLogger(Abstract${dto.name}.class);

  /** the deserializer used by the readObject method */
  private static final com.poesys.db.dto.Deserializer<Abstract${dto.name}> deserializer =
    new com.poesys.db.dto.Deserializer<Abstract${dto.name}>();
#if (${dto.objectProperties.size()} > 0)
  // Setter strategy nested classes for single-object associations
#end
  
#foreach($setter in $dto.objectProperties)
#set ($cappedName = ${stringUtils.capitalize($setter.uniqueName)})
#set ($realName = ${setter.dto.name})
## Only create a QuerySetter if the property is eagerly loaded.
#if(!$setter.lazy)
  /**
   * Nested class that manages the $setter.uniqueName association data
   *
   * Source: $setter.source
   *
   * @author Poesys/DB Cartridge
   */
  private class Query${cappedName}Setter extends com.poesys.db.dto.AbstractObjectSetter<${setter.className}> {
    private static final long serialVersionUID = 1L;
    
    /**
     * Create a Query${cappedName}Setter object.
     */
    public Query${cappedName}Setter() {
      super("${setter.dto.subsystem.fullyQualifiedName}", ${setter.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${setter.dto.packageName}.${setter.dto.name}.class.getName();
    }

    @Override
    protected IPrimaryKey getKey() {
      return ${setter.uniqueName}Key;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<${setter.className}> getSql() {
      return new ${setter.dto.packageName}.sql.Query${realName}();
    }

    @Override
    protected void set(${setter.className} dto) {
      // No status change, this is just filling in the object data.
      $setter.uniqueName = dto;
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated ${stringUtils.uncapitalize($setter.queryName)} is not null
      return $setter.uniqueName != null;
    }
  }

#end
## Only create insert and update setters for read/write nested classes.
#if ($setter.readWrite && $setter.dto.readWrite)
  /**
   * Insert setter for inserting nested object property ${stringUtils.uncapitalize($setter.queryName)}.
   */
  private class Insert${cappedName}Setter 
      extends com.poesys.db.dto.AbstractInsertSetter {
    // Property ${stringUtils.uncapitalize($setter.queryName)} source: ${setter.source}
    private static final long serialVersionUID = 1L;

    /**
     * Create an Insert${cappedName}Setter object.
     */
    public Insert${cappedName}Setter() {
      super("${setter.dto.subsystem.fullyQualifiedName}", ${setter.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${setter.dto.packageName}.${setter.dto.name}.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      array.add(${setter.uniqueName});
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      // Key type: $setter.classKeyType
#if ($setter.classKeyType.equals("IdentityKey"))
      return false;
#else
      return true;
#end
    }
  }

  /**
#if ($setter.child)
   * Setter for processing added ${setter.uniqueName} and updated ${setter.uniqueName}.
   * Deleted ${setter.uniqueName} is deleted in the database cascade delete.
#else
   * Setter for processing added ${setter.uniqueName}, updated ${setter.uniqueName}, and 
   * deleted ${setter.uniqueName}. 
#end
   */
   
  private class Update${cappedName}Setter 
      extends com.poesys.db.dto.AbstractProcessNestedObject<${setter.className}> {
    private static final long serialVersionUID = 1L;

    /**
     * Create an Update${cappedName}Setter object.
     */
    public Update${cappedName}Setter() {
      super("${setter.dto.subsystem.fullyQualifiedName}", ${setter.dto.expiration});
    }

    @Override
    protected void doChanged(java.sql.Connection connection, ${setter.className} dto)
        throws java.sql.SQLException, com.poesys.db.BatchException, com.poesys.db.ConstraintViolationException,
        com.poesys.db.dto.DtoStatusException {
        // ${stringUtils.uncapitalize($setter.queryName)} source: ${setter.source}
        // Immutable: ${setter.immutable}
#if (!${setter.immutable})
      com.poesys.db.dao.IDaoManager manager = 
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<${setter.className}> factory = 
        manager.getFactory(${setter.dto.packageName}.${setter.dto.name}.class.getName(), subsystem, ${setter.dto.expiration});
      com.poesys.db.dao.update.IUpdate<${setter.className}> updater = 
        factory.getUpdate(new ${setter.dto.packageName}.sql.Update${realName}());

#foreach ($super in $setter.dto.superclasses)
    // ${super.name}
    final com.poesys.db.dao.IDaoFactory<${super.packageName}.I${super.name}> ${super.nameAsProperty}Factory =
      manager.getFactory("${super.packageName}.${super.name}", "${super.subsystem.fullyQualifiedName}", ${super.expiration});
    com.poesys.db.dao.update.IUpdate<${super.packageName}.I${super.name}> ${super.nameAsProperty}Updater =
      ${super.nameAsProperty}Factory.getUpdate(new ${super.packageName}.sql.Update${super.name}());
    
#end
#set ($first = true)
#foreach ($super in $setter.dto.superclasses)
#if ($first)
      // Update the superclass objects from the root down.
#set ($first = false)
#end
      ${super.nameAsProperty}Updater.update(connection, dto);
#end
      // Update the leaf class.
      updater.setLeaf(true);
      updater.update(connection, dto);
      // Complete the update by setting the DTO to EXISTING status.
      dto.setExisting();
#end
    }
    
    @Override
    protected void doDeleted(java.sql.Connection connection, ${setter.className} dto)
        throws java.sql.SQLException, com.poesys.db.BatchException, com.poesys.db.ConstraintViolationException,
        com.poesys.db.dto.DtoStatusException {
#if (${dto.removable})
#if (${setter.child})
      // Delete cascades in the database
#else
      com.poesys.db.dao.IDaoManager manager = 
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<${setter.className}> factory = 
        manager.getFactory(${setter.dto.packageName}.${setter.dto.name}.class.getName(), subsystem, ${setter.dto.expiration});
      com.poesys.db.dao.delete.IDelete<${setter.className}> dao = 
        factory.getDelete(new ${setter.dto.packageName}.sql.Delete${realName}());
      dao.delete(connection, dto);
#end
#end
    }

    @Override
    protected void doNew(java.sql.Connection connection, ${setter.className} dto)
        throws java.sql.SQLException, com.poesys.db.BatchException, com.poesys.db.ConstraintViolationException,
        com.poesys.db.dto.DtoStatusException {
      com.poesys.db.dao.IDaoManager manager = 
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<${setter.className}> factory = 
        manager.getFactory(${setter.dto.packageName}.${setter.dto.name}.class.getName(), subsystem, ${setter.dto.expiration});
      com.poesys.db.dao.insert.IInsert<${setter.className}> inserter =
        factory.getInsert(new ${setter.dto.packageName}.sql.Insert${realName}(), createKey());

#foreach ($super in $dto.superclasses)
      // ${super.name}
      final com.poesys.db.dao.IDaoFactory<${super.packageName}.I${super.name}> ${super.nameAsProperty}Factory =
        manager.getFactory("${super.packageName}.${super.name}", "${super.subsystem.fullyQualifiedName}", ${super.expiration});
      com.poesys.db.dao.insert.IInsert<${super.packageName}.I${super.name}> ${super.nameAsProperty}Inserter =
#if ($dto.keyType == "IdentityKey" || $dto.inheritedKeyType == "IdentityKey")
        ${super.nameAsProperty}Factory.getInsert(new ${super.packageName}.sql.Insert${super.name}(), false);
#else
        ${super.nameAsProperty}Factory.getInsert(new ${super.packageName}.sql.Insert${super.name}(), true);
#end
#end

      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set 
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      dto.setSuppressNestedInserts(true);
      dto.setSuppressNestedPreInserts(false);
#set ($first = true)
#set ($second = false)
#foreach ($super in $dto.superclasses)
#if ($second)
      // Set pre-insert suppression on to suppress inserts in anything but root.
      dto.setSuppressNestedPreInserts(true);
#set ($second = false)
#else
#if ($first)
#set ($first = false)
#set ($second = true)
#end
#end
      ${super.nameAsProperty}Inserter.insert(connection, dto);
#end

      // Suppress inserts in concrete class.
      dto.setSuppressNestedPreInserts(true);
      
      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      dto.setSuppressNestedInserts(false);
      inserter.setLeaf(true);
      inserter.insert(connection, dto);
    }

    @Override
    protected ${setter.className} getDto() {
      return $setter.uniqueName;
    }
    
    @Override
    protected String getClassName() {
      return ${setter.dto.packageName}.${setter.dto.name}.class.getName();
    }

    @Override
    protected boolean createKey() {
      // Key type: $setter.classKeyType
#if ($setter.classKeyType.equals("IdentityKey"))
      return false;
#else
      return true;
#end
    }
  }
#end

#if (!$setter.lazy)
## Add the key object used by the query setter and instantiated by the subsystem factory.  
  /**
   * Foreign key object used by Query${cappedName}Setter nested class to query object
   */
  private IPrimaryKey ${setter.uniqueName}Key;
  
  /**
   * Set the foreign key ${setter.uniqueName}Key. This has package access to enable
   * the subsystem factory getData method to call this method to set the key
   * by creating it from the queried result set.
   *
   * @param ${setter.uniqueName}Key the foreign key
   */
  void ${setter.setterName}Key(IPrimaryKey ${setter.uniqueName}Key) {
    this.${setter.uniqueName}Key = ${setter.uniqueName}Key;
  }

#end
#end
#if ($dto.collectionProperties.size() > 0)
  // Setter strategy nested classes for multiple-object associations
#end

#foreach($setter in $dto.collectionProperties)
#set ($cappedName = $setter.queryName)
#set ($realName = ${setter.dto.name})
## Only create query setter for eagerly loaded properties.
#if(!$setter.lazy)
  /**
   * Query setter for querying nested ${setter.uniqueName}
   *
   * Source: ${setter.source}
   *
   * @see ${dto.packageName}.sql.Query${cappedName}By${dto.name}
   */
  private class Query${cappedName}Setter 
      extends com.poesys.db.dto.AbstractListSetter<${setter.className}, I${dto.name}, ${setter.typeName}> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = ${setter.fetchSize};

    /**
     * Create a Query${cappedName}Setter object.
     */
    public Query${cappedName}Setter() {
      super("${setter.dto.subsystem.fullyQualifiedName}", ${setter.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${setter.dto.packageName}.${setter.dto.name}.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected I${dto.name} getParametersDto() {
      return Abstract${dto.name}.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<${setter.className}, I${dto.name}> getSql() {
      return new ${dto.packageName}.sql.Query${cappedName}By${dto.name}();
    }

    @Override
    protected void set(${setter.typeName} list) {
      // No status change; this is just filling in the object data.
      ${stringUtils.uncapitalize($setter.queryName)} = list;
      // Add the primary keys to the serialized key list if there are any.
      if (${stringUtils.uncapitalize($setter.queryName)} != null) {
        for (com.poesys.db.dto.IDbDto object : ${stringUtils.uncapitalize($setter.queryName)}) {
          ${setter.uniqueName}Keys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated ${stringUtils.uncapitalize($setter.queryName)} list is not null
      return ${stringUtils.uncapitalize($setter.queryName)} != null;
    }
  }
#end
#if(!$dto.hasLazilyLoadedMember())
#if ($setter.ordered)

  /**
   * Read-Object setter for de-serializing nested ${stringUtils.uncapitalize($setter.queryName)} list
   *
   * Source: ${setter.source}
   *
   * @see ${dto.packageName}.sql.Query${setter.dto.name}
   */
  private class Read${cappedName}Setter 
      extends com.poesys.db.dto.AbstractListReadSetter<${setter.className}> {
    private static final long serialVersionUID = 1L;

    /**
     * Create a Read${cappedName}Setter object to read the ${stringUtils.uncapitalize($setter.queryName)} list.
     */
    public Read${cappedName}Setter() {
      super("${setter.dto.subsystem.fullyQualifiedName}", ${setter.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${setter.dto.packageName}.${setter.dto.name}.class.getName();
    }

    @Override
    protected ${setter.typeName} getObjectList() {
      return ${stringUtils.uncapitalize($setter.queryName)};
    }

    @Override
    protected java.util.List<IPrimaryKey> getPrimaryKeys() {
      return ${setter.uniqueName}Keys;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<${setter.className}> getSql() {
      return new ${dto.packageName}.sql.Query${setter.dto.name}();
    }

    @Override
    protected void set(${setter.typeName} list) {
      ${stringUtils.uncapitalize($setter.queryName)} = list;
    }
  }
#else

  /**
   * Read-Object setter for de-serializing nested ${stringUtils.uncapitalize($setter.queryName)} collection
   *
   * Source: ${setter.source}
   *
   * @see ${dto.packageName}.sql.Query${setter.dto.name}
   */
  private class Read${cappedName}Setter 
      extends com.poesys.db.dto.AbstractCollectionReadSetter<${setter.className}> {
    private static final long serialVersionUID = 1L;

    /**
     * Create a Read${cappedName}Setter object to read the ${stringUtils.uncapitalize($setter.queryName)} collection.
     */
    public Read${cappedName}Setter() {
      super("${setter.dto.subsystem.fullyQualifiedName}", ${setter.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${setter.dto.packageName}.${setter.dto.name}.class.getName();
    }

    @Override
    protected ${setter.typeName} getObjectCollection() {
      return ${stringUtils.uncapitalize($setter.queryName)};
    }

    @Override
    protected java.util.List<IPrimaryKey> getPrimaryKeys() {
      return ${setter.uniqueName}Keys;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<${setter.className}> getSql() {
      return new ${dto.packageName}.sql.Query${setter.dto.name}();
    }

    @Override
    protected void set(${setter.typeName} collection) {
     ${stringUtils.uncapitalize($setter.queryName)} = collection;
    }
  }
#end
#end
## Only create insert setters for read/write nested classes and read/write properties.
#if ($setter.readWrite && $setter.dto.readWrite)

  /**
   * Insert setter for inserting nested to-many association ${setter.uniqueName}.
   *
   * @see ${setter.dto.packageName}.sql.Insert${realName}
   */
  private class Insert${cappedName}Setter extends com.poesys.db.dto.AbstractInsertSetter {
    private static final long serialVersionUID = 1L;
    
    // Association ${stringUtils.uncapitalize($setter.queryName)} source: ${setter.source}

    /**
     * Create an Insert${cappedName}Setter object.
     */
    public Insert${cappedName}Setter() {
      super("${setter.dto.subsystem.fullyQualifiedName}", ${setter.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${setter.dto.packageName}.${setter.dto.name}.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = ${stringUtils.uncapitalize($setter.queryName)};
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
#if ($setter.classKeyType.equals("IdentityKey"))
      return false;
#else
      return true;
#end
    }
  }

  /**
#if ($setter.child)
   * Setter for processing added ${setter.uniqueName} and updated ${setter.uniqueName}.
   * Deleted ${setter.uniqueName} are deleted in the database cascade delete.
#else
   * Setter for processing added ${setter.uniqueName}, updated ${setter.uniqueName}, and 
   * deleted ${setter.uniqueName}. 
#end
   */
#end

## Only create update setters for read/write/mutable nested classes.
#if ($setter.readWrite && $setter.dto.readWrite && !$setter.dto.immutable)
  private class Update${cappedName}Setter 
      extends com.poesys.db.dto.AbstractProcessNestedObjects<${setter.className}, ${setter.typeName}> {
    private static final long serialVersionUID = 1L;
    private static final int BATCH_SIZE = ${setter.batchSize};

    /**
     * Create an Update${cappedName}Setter object.
     */
    public Update${cappedName}Setter() {
      super("${setter.dto.subsystem.fullyQualifiedName}", ${setter.dto.expiration});
    }

    @Override
    protected void doChanged(java.sql.Connection connection, ${setter.typeName} dtos)
        throws java.sql.SQLException, com.poesys.db.BatchException, com.poesys.db.ConstraintViolationException,
        com.poesys.db.dto.DtoStatusException {
      // ${stringUtils.uncapitalize($setter.queryName)} source: ${setter.source}
      // Immutable: ${setter.immutable}
#if (!${setter.immutable})
      com.poesys.db.dao.IDaoManager manager = 
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
#if ($setter.dto.superclasses.size() > 0)

      // Create superclass updaters.

#end    
#foreach ($super in $setter.dto.superclasses)
      // ${super.name}
      final com.poesys.db.dao.IDaoFactory<${super.packageName}.I${super.name}> ${super.nameAsProperty}Factory =
        manager.getFactory("${super.packageName}.${super.name}", "${super.subsystem.fullyQualifiedName}", ${super.expiration});
      com.poesys.db.dao.update.IUpdateBatch<${super.packageName}.I${super.name}> ${super.nameAsProperty}Updater =
        ${super.nameAsProperty}Factory.getUpdateBatch(new ${super.packageName}.sql.Update${super.name}());
      java.util.Collection<${super.packageName}.I${super.name}> ${super.nameAsProperty}Dtos = convertDtoList(dtos);
    
#end

      com.poesys.db.dao.IDaoFactory<${setter.className}> factory = 
        manager.getFactory(${setter.dto.packageName}.${setter.dto.name}.class.getName(), subsystem, ${setter.dto.expiration});
      com.poesys.db.dao.update.IUpdateBatch<${setter.className}> updater =
        factory.getUpdateBatch(new ${setter.dto.packageName}.sql.Update${realName}());
#if ($setter.dto.superclasses.size() > 0)

      // Update the superclass objects from the root down.
#foreach ($super in $setter.dto.superclasses)
      ${super.nameAsProperty}Updater.update(connection, ${super.nameAsProperty}Dtos, ${super.nameAsProperty}Dtos.size() / 2);
#end
#end

      // Update the object of the leaf class.
      updater.setLeaf(true);
      updater.update(connection, dtos, dtos.size() / 2);
      // Complete the update by setting the DTOs to EXISTING status.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        if (dto.getStatus() == Status.CHANGED) {
          dto.setExisting();
        }
      }
#end
    }
    
    @Override
    protected void doDeleted(java.sql.Connection connection, ${setter.typeName} dtos)
        throws java.sql.SQLException, com.poesys.db.BatchException, com.poesys.db.ConstraintViolationException,
        com.poesys.db.dto.DtoStatusException {
#if (${dto.removable})
      com.poesys.db.dao.IDaoManager manager = 
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<${setter.className}> factory = 
        manager.getFactory(${setter.dto.packageName}.${setter.dto.name}.class.getName(), subsystem, ${setter.dto.expiration});
      com.poesys.db.dao.delete.IDeleteBatch<${setter.className}> dao = 
        factory.getDeleteBatch(new ${setter.dto.packageName}.sql.Delete${realName}());
      dao.delete(connection, dtos, BATCH_SIZE);
#end
    }

    @Override
    protected void doNew(java.sql.Connection connection, ${setter.typeName} dtos)
        throws java.sql.SQLException, com.poesys.db.BatchException, com.poesys.db.ConstraintViolationException,
        com.poesys.db.dto.DtoStatusException {
      com.poesys.db.dao.IDaoManager manager = 
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

#if ($setter.dto.superclasses.size() > 0)
    // Create superclass inserters.

#end    
#foreach ($super in $setter.dto.superclasses)
    // ${super.name}
    final com.poesys.db.dao.IDaoFactory<${super.packageName}.I${super.name}> ${super.nameAsProperty}Factory =
      manager.getFactory("${super.packageName}.${super.name}", "${super.subsystem.fullyQualifiedName}", ${super.expiration});
    // Key type: ${super.keyType}, Inherited Key type: $super.inheritedKeyType
#if ($super.keyType == "IdentityKey" || $super.inheritedKeyType == "IdentityKey")
    com.poesys.db.dao.insert.IInsertCollection<${super.packageName}.I${super.name}> ${super.nameAsProperty}Inserter =
      ${super.nameAsProperty}Factory.getInsertCollection(new ${super.packageName}.sql.Insert${super.name}(), false);
#else
    com.poesys.db.dao.insert.IInsertBatch<${super.packageName}.I${super.name}> ${super.nameAsProperty}Inserter =
      ${super.nameAsProperty}Factory.getInsertBatch(new ${super.packageName}.sql.Insert${super.name}());
#end
    java.util.Collection<${super.packageName}.I${super.name}> ${super.nameAsProperty}Dtos = convertDtoList(dtos);
    
#end

      com.poesys.db.dao.IDaoFactory<${setter.className}> factory = 
        manager.getFactory(${setter.dto.packageName}.${setter.dto.name}.class.getName(), subsystem, ${setter.dto.expiration});
      com.poesys.db.dao.insert.IInsertBatch<${setter.className}> inserter =
        factory.getInsertBatch(new ${setter.dto.packageName}.sql.Insert${realName}());


#if ($setter.dto.superclasses.size() > 0)
      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set 
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(true);
        dto.setSuppressNestedPreInserts(false);
      }
#set ($first = true)
#set ($second = false)
#foreach ($super in $setter.dto.superclasses)
#if ($second)
      // Set pre-insert suppression on to suppress inserts in anything but root.
      for (com.poesys.db.dto.IDbDto dto : ${super.nameAsProperty}Dtos) {
        dto.setSuppressNestedPreInserts(true);
      }
#set ($second = false)
#else
#if ($first)
#set ($first = false)
#set ($second = true)
#end
#end
#if ($super.keyType == "IdentityKey" || $super.inheritedKeyType == "IdentityKey")
      ${super.nameAsProperty}Inserter.insert(connection, ${super.nameAsProperty}Dtos);
#else
      ${super.nameAsProperty}Inserter.insert(connection, ${super.nameAsProperty}Dtos, ${super.nameAsProperty}Dtos.size() / 2);
#end
#end
#end
      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(false);
      }
      inserter.setLeaf(true);
#if ($setter.dto.keyType == "IdentityKey" || $setter.dto.inheritedKeyType == "IdentityKey")
      inserter.insert(connection, (java.util.Collection<${setter.className}>)dtos, dtos.size() / 2);
#else
      inserter.insert(connection, dtos, dtos.size() / 2);
#end
    }

    @Override
    protected ${setter.typeName} getDtos() {
      return ${stringUtils.uncapitalize($setter.queryName)};
    }
    
    @Override
    protected String getClassName() {
      return ${setter.dto.packageName}.${setter.dto.name}.class.getName();
    }
  }

#end
## Only create add method for a read/write/mutable DTO.
#if ($dto.readWrite && !$dto.immutable)
  /**
   * Add ${setter.className} object to ${stringUtils.uncapitalize($setter.queryName)} collection.
   * 
   * @param object the ${setter.className} object
   */
  ${setter.visibility} void add${setter.queryName}${setter.dto.name}(${setter.className} object) {
    if (${stringUtils.uncapitalize($setter.queryName)} == null) {
      // Association not yet created, create it.
      ${stringUtils.uncapitalize($setter.queryName)} = new java.util.concurrent.CopyOnWriteArrayList<${setter.className}>();
    }
    ${stringUtils.uncapitalize($setter.queryName)}.add(object);
    // Add the primary key to the primary key array.
    ${setter.uniqueName}Keys.add(object.getPrimaryKey());
  }
   
#end
#end
  /**
   * Create an empty ${dto.name} for use in building a new object. The 
   * concrete subclass must call this constructor.
   */
  public Abstract${dto.name}() {
#if (${dto.superclass})
    super();
#end
## Set the abstractClass flag.
#if ($dto.abstractClass)
    abstractClass = true;
#else
    abstractClass = false;
#end
    createInserters();
## Instantiate setter arrays if there are any nested objects.
#if ($dto.objectProperties.size() > 0 || $dto.collectionProperties.size() > 0)

    // Setter arrays (create if null)
    if (querySetters == null) {
      querySetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertSetters == null) {
      insertSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    }
    if (preSetters == null) {
      preSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    }
    if (postSetters == null) {
      postSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    }
    if (readObjectSetters == null) {
      readObjectSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    }
#end
#foreach($setter in $dto.objectProperties)
#if($setter.toMany)
#set ($cappedName = $setter.queryName)
#else
#set ($cappedName = ${stringUtils.capitalize($setter.uniqueName)})
#end

    // Add the setters for the ${stringUtils.uncapitalize($setter.queryName)} property.
## Only add the query setter if the property loads eagerly.
#if(!$setter.lazy)
    querySetters.add(new Query${cappedName}Setter());
#end
## Only create insert setters for to-one child read/write nested classes.
#if ($setter.readWrite && $setter.dto.readWrite && $setter.child)
    insertSetters.add(new Insert${cappedName}Setter());
#end
## Only create insert pre setters for to-one non-child read/write nested classes.
#if ($setter.readWrite && $setter.dto.readWrite && !$setter.child)
    preSetters.add(new Insert${cappedName}Setter());
#end
## Only create update setters for read/write/mutable nested classes.
#if ($setter.readWrite && $setter.dto.readWrite && !$setter.dto.immutable)
    postSetters.add(new Update${cappedName}Setter());
#end
#end
#foreach($setter in $dto.collectionProperties)
## Don't add the setters if this is a lazily loaded property.
#set ($cappedName = $setter.queryName)
    
    // Add the many-to-many collection setters for the ${stringUtils.uncapitalize($setter.queryName)} property.
## Only add the query setter if the property loads eagerly.
#if(!$setter.lazy)
    querySetters.add(new Query${cappedName}Setter());
#end
## Create read-object setters if there is no proxy.
#if(!$dto.hasLazilyLoadedMember())
    readObjectSetters.add(new Read${cappedName}Setter());
#end
## Only create insert setters for read/write nested classes.
#if ($setter.readWrite && $setter.dto.readWrite)
    insertSetters.add(new Insert${cappedName}Setter());
#end
## Only create update setters for read/write/mutable nested classes.
#if ($setter.readWrite && $setter.dto.readWrite && !$setter.dto.immutable)
    postSetters.add(new Update${cappedName}Setter());
#end
#end
  }

  /**
   * Create a ${dto.name}. The concrete subclass must call this constructor.
   *
   * @param key the primary key of the ${dto.name}
#foreach ($key in $dto.associatedKeys)
   * @param ${key.name}Object wraps an associated I${key.typeName} object
#end
#foreach ($property in $dto.constructorArgs)
   * @param ${property.uniqueName} ${property.paramTag}
#end
   */
  public Abstract${dto.name}(IPrimaryKey key#foreach ($key in $dto.associatedKeys), ${key.packageName}.I${key.typeName} ${key.name}Object#end#foreach ($property in $dto.constructorArgs), ${property.typeName} ${property.uniqueName}#end) {
#if (${dto.superclass})
## Get the last in the list of superclasses (immediate superclass)
#foreach($class in $dto.superclasses)
#set($superclass = $class)
#end
    super(key#foreach ($property in $superclass.constructorArgs), ${property.uniqueName}#end);
#else
    this.key = key;
#end

#foreach ($property in $dto.localMembers)
    this.${property.uniqueName} = ${property.uniqueName};

## Check that the required properties are not null, except for lazily loaded ones and
## object properties, which are set below by setters using the non-null id property.
#if (${property.required} && !${property.lazy} && ${property.source} != "AddToOneAssociationRequiredObjectProperties")
    if (${property.uniqueName} == null#if ($dto.keyType == "IdentityKey") && !getStatus().equals(Status.NEW)#end) {
      throw new com.poesys.db.InvalidParametersException("${property.uniqueName} is required for " + key.getValueList());
    }
    
#end
#if (${property.default})
    if (${property.uniqueName} == null) {
      this.${property.uniqueName} = ${property.default};
    }
    
#end
#end
## Set any associated objects passed in as arguments.
#foreach ($key in $dto.associatedKeys)
    // Associated key object
    ${key.objectName} = ${key.name}Object;
    
#end
## Instantiate setter arrays if there are any nested objects.
#if ($dto.objectProperties.size() > 0 || $dto.collectionProperties.size() > 0)
    // Setter arrays (create if null)
    if (querySetters == null) {
      querySetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertQuerySetters == null) {
      insertQuerySetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertSetters == null) {
      insertSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (preSetters == null) {
      preSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postSetters == null) {
      postSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (readObjectSetters == null) {
      readObjectSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
#end
#foreach($setter in $dto.objectProperties)
#set ($cappedName = ${stringUtils.capitalize($setter.uniqueName)})
    
    // Add the setters for the $setter.uniqueName property.
#if(!$setter.lazy)
    querySetters.add(new Query${cappedName}Setter());
    // Set the object property primary key with a factory method.
#set($foreignkey=$setter.dto.getForeignKey($setter.uniqueName))
    // TODO: fix problem with foreign keys/associated keys VND-168
    // ${setter.uniqueName}Key = ${setter.dto.packageName}.${stringUtils.capitalize(${setter.dto.subsystem.name})}Factory.get${setter.dto.name}PrimaryKey(#set ($sep = "")#foreach ($key in $foreignKey.keyProperties)${sep}${key.uniqueName}#set ($sep=", ")#end);
#end
## Only create insert setters for read/write nested classes.
#if ($setter.readWrite && $setter.readWrite && $setter.dto.readWrite)
    insertSetters.add(new Insert${cappedName}Setter());
#end
## Only create Insert pre setters for to-one non-child read/write nested classes.
#if ($setter.readWrite && $setter.dto.readWrite && !$setter.child)
    preSetters.add(new Insert${cappedName}Setter());
#end
## Only create update setters for read/write/mutable nested classes.
#if ($setter.readWrite && $setter.dto.readWrite && !$setter.dto.immutable)
    postSetters.add(new Update${cappedName}Setter());
#end
    
#if ($foreignKey.required)
## This foreign key must have a value before insert, add an insert query setter.
    // Add a setter to instantiate the required $setter.uniqueName object before insert.
    insertQuerySetters.add(new Query${cappedName}Setter());
#end
#end
#foreach($setter in $dto.collectionProperties)
#set ($cappedName = $setter.queryName)
    
    // Add the many-to-many collection setters for the $setter.uniqueName property.
## Only create query setters for non-lazily-loaded classes.
#if(!$setter.lazy)
    querySetters.add(new Query${cappedName}Setter());
#end
## Create read-object setters if there will be no proxy.
#if(!$dto.hasLazilyLoadedMember())
    readObjectSetters.add(new Read${cappedName}Setter());
#end
## Only create insert setters for read/write nested classes.
#if ($setter.readWrite && $setter.readWrite && $setter.dto.readWrite)
    insertSetters.add(new Insert${cappedName}Setter());
#end
## Only create update setters for read/write/mutable nested classes.
#if ($setter.readWrite && $setter.dto.readWrite && !$setter.dto.immutable)
    postSetters.add(new Update${cappedName}Setter());
#end
#end
## Set the abstractClass flag.
#if ($dto.abstractClass)
    abstractClass = true;
#else
    abstractClass = false;
#end
    createInserters();
  }

  /**
   * Read an object from an input stream, de-serializing it. Each generated
   * class must have this private method, which the deserialize method calls
   * through Java reflection on the specific class. The class calls a shared
   * code method to run the readObjectSetters.
   * 
   * @param in the object input stream
   * @throws ClassNotFoundException when a nested object class can't be found
   * @throws IOException when there is an IO problem reading the stream
   */
  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException,
      ClassNotFoundException {
    logger.debug("Deserializing object of class " + this.getClass().getName()
                 + " with readObject in Abstract${dto.name}");
    // Do the read-object deserialization.
    deserializer.doReadObject(in, this);
  }
   
#if (!${dto.superclass})
  @Override
  public boolean equals(Object arg0) {
    I${dto.name} other = (I${dto.name})arg0;
    return other.getPrimaryKey().equals(key);
  }

  @Override
  public int hashCode() {
    return key.hashCode();
  }

  @Override
  public int compareTo(com.poesys.db.dto.IDbDto o) {
    I${dto.name} other = (I${dto.name})o;
    // Sort on the key. Same semantics as equals and hashCode().
    return other.getPrimaryKey().compareTo(key);
  }
  
  @Override
  public String getSubsystem() {
    return "${dto.subsystem.fullyQualifiedName}";
  }

  @Override
  public void markChildrenDeleted() throws DtoStatusException {
#foreach ($property in $dto.childProperties)
#if ($property.toMany)
#set ($propertyName = ${stringUtils.uncapitalize(${property.queryName})})
#else
#set ($propertyName = ${property.uniqueName})
#end
    // Only process deletes if child exists.
    if (${propertyName} != null) {
#if ($property.toMany)
      for (com.poesys.db.dto.IDbDto dto : ${propertyName}) {
        dto.cascadeDelete();
      }
#else
      ${property.uniqueName}.cascadeDelete();
#end
    }
#end
  }

  @Override
  public IPrimaryKey getPrimaryKey() {
    return key;
  }
  
  @Override
  public java.sql.Connection getConnection() throws java.sql.SQLException {
    java.sql.Connection connection = null;
    
	/* 
	 * The resource bundle for the DTO's subsystem contains the suffix that
	 * distinguishes multiple versions of the subsystem in the database.properties
	 * file, such as "prod" or "test". Most database.properties files have only
	 * one implementation and use external facilities to switch between the
	 * databases (JNDI, for example, or producing different database.properties
	 * files in different setups). Use the subsystem resource bundle to get the
	 * suffix, then use the full subsystem name to get a connection factory for
	 * the DTO's subsystem, then use that factory to get a JDBC connection.
	 */
	java.util.ResourceBundle rb = 
	  java.util.ResourceBundle.getBundle("${dto.subsystem.fullyQualifiedName}");
    String subsystem =
      "${dto.subsystem.fullyQualifiedName}"
          + (rb.getString("suffix") == null
             || rb.getString("suffix").length() == 0 ? ""
              : "." + rb.getString("suffix"));
	  
	try {
	  connection = 
	    com.poesys.db.connection.ConnectionFactoryFactory.getInstance(subsystem).getConnection();
	} catch (com.poesys.db.InvalidParametersException e) {
	  throw new java.sql.SQLException(e.getMessage());
	} catch (java.io.IOException e) {
	  throw new java.sql.SQLException(e.getMessage());
	}
	
	return connection;
  }
#end
## Generate access methods for data members (local and association properties)
#foreach ($property in $dto.dataMembers)
#if ($property.toMany)
#set ($propertyName = ${stringUtils.uncapitalize(${property.queryName})})
#else
#set ($propertyName = ${property.uniqueName})
#end
  /**
   * Nested property $propertyName
   *
${property.documentation}
   *
   * Added by ${property.source}
   * Class is read/write: ${dto.readWrite}
   * Class is immutable: ${dto.immutable}
   * Property is read/write: ${property.readWrite}
   * Property is lazy: ${property.lazy}
   */
#if ($property.toMany)
#set ($methodName = ${property.queryGetterName})
#if ($property.ordered)
#set ($collectionType = "a list")
#else
#set ($collectionType = "a collection")
#end
## Make the list or collection transient so it won't serialize.
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient ${property.typeName} ${propertyName};
## Generate a non-transient list of primary keys for de-serialization.
  // Ordered list of keys of the objects in the ${propertyName} list
  java.util.List<com.poesys.db.pk.IPrimaryKey> ${property.uniqueName}Keys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
#else
#set ($methodName = ${property.getterName})
  private ${property.typeName} ${propertyName};
#set ($collectionType = "an object")
#end
  
  /**
   * Get ${collectionType} of ${property.className}.
   *
   * Source: $property.source
   * 
   * @return a ${property.typeName}
#if ($property.lazy)
   * @throws java.sql.SQLException when there is a database problem
#end
   */

  ${property.visibility} ${property.typeName} ${methodName}() #if ($property.lazy)throws java.sql.SQLException #end{
    return ${propertyName};
  }

  /**
   * Clear the ${propertyName} data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  ${property.visibility} void clear${stringUtils.capitalize(${propertyName})}() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }
## Only output a setter if the DTO is read/write and mutable and property is
## read/write or lazy and mutable.
#if ((${dto.readWrite} && !${dto.immutable} && !${property.immutable} && ${property.readWrite}) || ${property.lazy})

#if (${property.readWrite})
  /**
   * <p>
   * Set the ${propertyName}.
   * </p>
   * <ul>
   * <li>Read/Write DTO: ${dto.readWrite}</li>
   * <li>Immutable DTO: ${dto.immutable}</li>
   * <li>Read/Write property: ${property.readWrite}</li>
   * <li>Immutable property: ${property.immutable}</li>
   * <li>Lazy property: ${property.lazy} (if true, proxy calls this method)</li>
   * </ul>
#if ($property.documentation != "")
$property.documentation
#end
   *
   * @param ${propertyName} the value with which to set the property
#if (${property.required})
   * @throws com.poesys.db.InvalidParametersException when the input ${propertyName} is null
#end
   */
#end
#if (${property.required})
 #if(${property.readWrite}) ${property.visibility}#end void ${property.setterName}(${property.typeName} ${propertyName})
      throws com.poesys.db.InvalidParametersException {
#else
 #if (${dto.readWrite} && !${dto.immutable} && !${property.immutable} && ${property.readWrite}) public #else ${property.visibility}#end void ${property.setterName}(${property.typeName} ${propertyName}) {
#end    
#if (${property.required})
    if (${propertyName} == null) {
      throw new com.poesys.db.InvalidParametersException("${propertyName} is required");
    }
    
#end
    this.${propertyName} = ${propertyName};
## For eager, to-one object properties, add primary key field setting (association end means it's an object property)
#if (!$property.lazy && !$property.toMany && $property.associationEnd)
    // Set the IPrimaryKey cache lookup key.
    this.${property.uniqueName}Key = ${property.uniqueName}.getPrimaryKey();
## TODO set the primary key fields of the property; currently don't have the dto object for the property, so can't get associated keys
#end
#if ($property.toMany)
    // Add the primary keys of the new collection to the serialized key list.
    ${property.uniqueName}Keys.clear();
    if (${propertyName} != null) {
      for (com.poesys.db.dto.IDbDto object : ${propertyName}) {
        ${property.uniqueName}Keys.add(object.getPrimaryKey());
      }
    }
#end
    setChanged();
  }
#end
#end
## Produce an overriding finalizeInsert method for Identity key classes.
#if ($dto.keyType == "IdentityKey")

  @Override
  public void finalizeInsert(java.sql.PreparedStatement stmt) throws java.sql.SQLException {
    // Set the key attribute.
    java.sql.ResultSet rs = stmt.getGeneratedKeys();
    if (rs.next()) {
      // Get the key value.
      java.math.BigDecimal decimalValue = rs.getBigDecimal(1);
      // Convert the value to a big integer and assign.
      ${dto.localMembers.get(0).uniqueName} = decimalValue.toBigInteger();
    }
  }
#end
## Observer update for propagating delete cleanup

  @Override
  public void update(com.poesys.db.dto.ISubject subject,
                     com.poesys.db.dao.DataEvent event)
      throws com.poesys.db.dto.DtoStatusException {
#foreach ($property in $dto.childProperties)

    // Clean up ${stringUtils.uncapitalize($property.queryName)}.
    if (subject != null && subject instanceof ${property.className} && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        ${stringUtils.uncapitalize($property.queryName)} != null) {
#if ($property.toMany)
      // Delete to-many ${stringUtils.uncapitalize($property.queryName)} child from collection
      ${stringUtils.uncapitalize($property.queryName)}.remove(subject);
#end
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }
#end
#foreach($property in $dto.collectionProperties)
## Only process association types
#if ($property.classKeyType == "AssociationKey")

    // Cascade delete to ${stringUtils.uncapitalize($property.queryName)}.
    if (event == com.poesys.db.dao.DataEvent.MARKED_DELETED &&
        ${stringUtils.uncapitalize($property.queryName)} != null) {
      // Mark ${stringUtils.uncapitalize($property.queryName)} association object cascade-deleted.
      outer: for (${property.className} value : ${stringUtils.uncapitalize($property.queryName)}) {
        com.poesys.db.pk.AssociationPrimaryKey keys = 
          (com.poesys.db.pk.AssociationPrimaryKey) value.getPrimaryKey();
        for (com.poesys.db.pk.IPrimaryKey key : keys.getKeyListCopy()) {
          if (key.equals(subject.getPrimaryKey())) {
            value.cascadeDelete();
            break outer;
          }
        }
      }
    }
#end
#end
  }

  /**
   * Create the inserters for the ${dto.name} and its superclasses.
   */
  private void createInserters() {
    com.poesys.db.dao.IDaoManager manager =
      com.poesys.db.dao.DaoManagerFactory.getManager(getSubsystem());
    final com.poesys.db.dao.IDaoFactory<${dto.packageName}.I${dto.name}> ${stringUtils.uncapitalize(${dto.name})}Factory =
      manager.getFactory("${dto.packageName}.${dto.name}",
                         getSubsystem(),
                         2147483647);
    com.poesys.db.dao.insert.IInsertSql<I${dto.name}> sql =
      new ${dto.packageName}.sql.Insert${dto.name}();
#if ($dto.keyType == "Identity" || $dto.inheritedKeyType == "Identity")
#set($getKey = "false")
#else
#set($getKey = "true")
#end
    com.poesys.db.dao.insert.IInsert<I${dto.name}> inserter =
      ${stringUtils.uncapitalize(${dto.name})}Factory.getInsert(sql, ${getKey});
    inserters.add(inserter);
  }
}