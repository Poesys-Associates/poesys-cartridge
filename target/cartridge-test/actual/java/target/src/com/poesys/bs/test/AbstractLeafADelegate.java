/**
 * Copyright 2009 Poesys Associates. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDelegate.vsl

package com.poesys.bs.test;


import com.poesys.bs.delegate.AbstractDataDelegate;
import com.poesys.bs.delegate.DelegateException;
import com.poesys.db.connection.IConnectionFactory.DBMS;
import com.poesys.db.dao.insert.IInsertSql;
import com.poesys.db.dao.update.IUpdateSql;
import com.poesys.db.dao.delete.IDeleteSql;
import com.poesys.db.dao.query.IKeyQuerySql;
import com.poesys.db.dao.query.IQuerySql;


/**
 * <p>
 * A business delegate that provides an application programming interface for
 * LeafA objects and their dependents. You should not modify this class;
 * instead, override or add methods in the class LeafADelegate, which
 * specializes this class.
 * </p>
 * 
 * @see LeafADelegate
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractLeafADelegate
    extends AbstractDataDelegate<BsLeafA, com.poesys.db.test.ILeafA, com.poesys.db.pk.SequencePrimaryKey> {
  /**
   * Create an AbstractLeafADelegate object by supplying the database
   * subsystem in the database.properties file.
   * 
   * @param subsystem the database subsystem to use in database.properties
   */
  public AbstractLeafADelegate(String subsystem) {
    super(subsystem, 2147483647);
  }

  /**
   * Create an AbstractLeafADelegate object by supplying the database
   * subsystem in the database.properties file and a specific DBMS, usually
   * IConnectionFactory.DBMS.JNDI.
   * 
   * @param subsystem the database subsystem to use in database.properties
   * @param dbms the DBMS to use (usually IConnectionFactory.DBMS.JNDI)
   */
  public AbstractLeafADelegate(String subsystem, DBMS dbms) {
    super(subsystem, dbms, 2147483647);
  }

  @Override
  protected String getClassName() {
    return com.poesys.db.test.LeafA.class.getName();
  }

  @Override
  protected IInsertSql<com.poesys.db.test.ILeafA> getInsertSql() {
    return new com.poesys.db.test.sql.InsertLeafA();
  }

  @Override
  protected IDeleteSql<com.poesys.db.test.ILeafA> getDeleteSql() {
    return new com.poesys.db.test.sql.DeleteLeafA();
  }

  @Override
  protected IUpdateSql<com.poesys.db.test.ILeafA> getUpdateSql() {
    return new com.poesys.db.test.sql.UpdateLeafA();
  }

  @Override
  protected IKeyQuerySql<com.poesys.db.test.ILeafA> getQueryByKeySql() {
    return new com.poesys.db.test.sql.QueryLeafA();
  }

  @Override
  protected IQuerySql<com.poesys.db.test.ILeafA> getQueryListSql() {
    // Query-All method not required
    return new com.poesys.db.test.sql.QueryAllLeafA();
  }

  @Override
  protected com.poesys.bs.test.BsLeafA wrapData(com.poesys.db.test.ILeafA dto) {
    return new com.poesys.bs.test.BsLeafA(dto);
  }

  /**
   * <p>
   * Create a new LeafA with data fields.
   * </p>
   * <p>
   * The LeafA class has no key of its own but inherits from a superclass
   * that has a SequenceKey. When you create an instance of this
   * class, the delegate creates a key of that type in the superclass.
   * </p>
   * 
   * @param baseId primary key attribute
   * @param baseString 
   * @param middleString 
   * @param aString 
   * @return the new LeafA object
   * @throws DelegateException when there is a problem generating the key or
   *             creating the object
   */
  public com.poesys.bs.test.BsLeafA createLeafA(java.math.BigInteger baseId, java.lang.String baseString, java.lang.String middleString, java.lang.String aString)
      throws DelegateException {
      com.poesys.db.pk.SequencePrimaryKey key = null;

    // Generate a new LeafA id if the input key is null.
    if (baseId == null) {
      java.sql.Connection connection = null;
      try {
        connection = getConnection();
        if (connection == null) {
          throw new DelegateException("Could not get database connection to generate sequence");
        }
        
        if (dbms.equals(DBMS.MYSQL) || dbms.equals(DBMS.JNDI_MYSQL)) {
          key =
            com.poesys.db.pk.PrimaryKeyFactory.createMySqlSequenceKey(connection,
                                                                      "Base",
                                                                      "baseId",
                                                                      "com.poesys.db.test.LeafA");
        } else if (dbms.equals(DBMS.ORACLE) || dbms.equals(DBMS.JNDI_ORACLE)) {
          // Create key with sequence Base
          key =
            com.poesys.db.pk.PrimaryKeyFactory.createOracleSequenceKey(connection,
                                                                       "Base",
                                                                       "baseId",
                                                                       "com.poesys.db.test.LeafA");
        } else {
          throw new DelegateException("com.poesys.bs.delegate.msg.noDbms");
        }
        // Get the sequence number for use as an attribute value.
        baseId = key.getValue();
      } catch (com.poesys.db.InvalidParametersException e) {
        Object[] args = e.getParameters().toArray();
        String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
        throw new DelegateException(message, e);
      } catch (com.poesys.db.NoPrimaryKeyException e) {
        Object[] args = e.getParameters().toArray();
        String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
        throw new DelegateException(message, e);
      } catch (java.sql.SQLException e) {
        throw new DelegateException(e.getMessage(), e);
      } finally {
        // Done with this connection, close it and return it to the pool.
        if (connection != null) {
          try {
            connection.close();
          } catch (java.sql.SQLException e) {
            throw new DelegateException(e.getMessage(), e);
          }
        }
      }
    } else {
      key = com.poesys.db.pk.PrimaryKeyFactory.createSequenceKey("baseId", baseId, "com.poesys.db.test.LeafA");
    }

    // Create a data-access DTO for direct access, no proxy required.
    com.poesys.db.test.ILeafA dto =
      new com.poesys.db.test.LeafA(key, baseId, baseString, middleString, aString);

    // Create the business DTO.
    return new com.poesys.bs.test.BsLeafA(dto);
  }


  @Override
  public void insert(java.util.List<BsLeafA> list) throws DelegateException {
    java.sql.Connection c = getConnection();
    
    // Create superclass inserters.
    
    // Base
    final com.poesys.db.dao.IDaoFactory<com.poesys.db.test.IBase> baseFactory =
      manager.getFactory("com.poesys.db.test.Base", "com.poesys.db.test", 2147483647);
    // Key type: SequenceKey, Inherited Key type: None
    com.poesys.db.dao.insert.IInsertBatch<com.poesys.db.test.IBase> baseInserter =
      baseFactory.getInsertBatch(new com.poesys.db.test.sql.InsertBase());
    java.util.Collection<com.poesys.db.test.IBase> baseDtos = convertDtoList(list);
    
    // Middle
    final com.poesys.db.dao.IDaoFactory<com.poesys.db.test.IMiddle> middleFactory =
      manager.getFactory("com.poesys.db.test.Middle", "com.poesys.db.test", 2147483647);
    // Key type: None, Inherited Key type: SequenceKey
    com.poesys.db.dao.insert.IInsertBatch<com.poesys.db.test.IMiddle> middleInserter =
      middleFactory.getInsertBatch(new com.poesys.db.test.sql.InsertMiddle());
    java.util.Collection<com.poesys.db.test.IMiddle> middleDtos = convertDtoList(list);
    
    // LeafA (uses standard class factory from AbstractDataDelegate) None SequenceKey
    com.poesys.db.dao.insert.IInsertBatch<com.poesys.db.test.ILeafA> leafAInserter =
      factory.getInsertBatch(getInsertSql());
    java.util.Collection<com.poesys.db.test.ILeafA> leafADtos = convertDtoList(list);

    try {
      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set 
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      for (com.poesys.db.dto.IDbDto dto : leafADtos) {
        dto.setSuppressNestedInserts(true);
        dto.setSuppressNestedPreInserts(false);
      }
      baseInserter.insert(c, baseDtos, baseDtos.size() / 2);
      // Set pre-insert suppression on to suppress inserts in anything but root.
      for (com.poesys.db.dto.IDbDto dto : leafADtos) {
        dto.setSuppressNestedPreInserts(true);
      }
      middleInserter.insert(c, middleDtos, middleDtos.size() / 2);
      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : leafADtos) {
        dto.setSuppressNestedInserts(false);
      }
      leafAInserter.insert(c, leafADtos, leafADtos.size() / 2);
      
    } catch (com.poesys.db.ConstraintViolationException e) {
      rollBack(c, e.getMessage(), e);
    } catch (java.sql.SQLException e) {
      rollBack(c, e.getMessage(), e);
    } catch (com.poesys.db.BatchException e) {
      // Don't roll back the whole transaction; the DBMS rolls back the
      // individual inserts that failed, but the rest should be committed.
      String message = com.poesys.db.Message.getMessage(e.getMessage(), null);
      throw new DelegateException(message, e);
    } catch (com.poesys.db.dto.DtoStatusException e) {
      rollBack(c, e.getMessage(), e);
    } finally {
      commit(c);
      close(c);
      finalizeStatus(leafADtos, com.poesys.db.dto.IDbDto.Status.EXISTING);
    }
  }

  @Override
  public void process(java.util.List<BsLeafA> list) throws DelegateException {
    java.sql.Connection c = getConnection();

    // Create the 3 DAOs for inserting, updating, and deleting the concrete object.
    com.poesys.db.dao.insert.IInsertBatch<com.poesys.db.test.ILeafA> inserter = 
      factory.getInsertBatch(getInsertSql());
    com.poesys.db.dao.update.IUpdateBatch<com.poesys.db.test.ILeafA> updater = 
      factory.getUpdateBatch(getUpdateSql());
    java.util.Collection<com.poesys.db.test.ILeafA> dtos = convertDtoList(list);

    // Create the DAOs for inserting or updating the superclasses.
    try {
      // Base
      final com.poesys.db.dao.IDaoFactory<com.poesys.db.test.IBase> baseFactory =
        manager.getFactory("com.poesys.db.test.Base", "com.poesys.db.test.Base", 2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.db.test.IBase> baseInserter =
        baseFactory.getInsertBatch(new com.poesys.db.test.sql.InsertBase());
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.db.test.IBase> baseUpdater =
        baseFactory.getUpdateBatch(new com.poesys.db.test.sql.UpdateBase());
      java.util.Collection<com.poesys.db.test.IBase> baseDtos = convertDtoList(list);
      // If there is a root superclass, create a deleter for the root class.
      // The delete will cascade through foreign key constraints.
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.db.test.IBase> deleter = 
        baseFactory.getDeleteBatch(new com.poesys.db.test.sql.DeleteBase());
      if (deleter != null) {
        deleter.delete(c, baseDtos, baseDtos.size()/2);
      }
    
      // Middle
      final com.poesys.db.dao.IDaoFactory<com.poesys.db.test.IMiddle> middleFactory =
        manager.getFactory("com.poesys.db.test.Middle", "com.poesys.db.test.Middle", 2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.db.test.IMiddle> middleInserter =
        middleFactory.getInsertBatch(new com.poesys.db.test.sql.InsertMiddle());
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.db.test.IMiddle> middleUpdater =
        middleFactory.getUpdateBatch(new com.poesys.db.test.sql.UpdateMiddle());
      java.util.Collection<com.poesys.db.test.IMiddle> middleDtos = convertDtoList(list);
    
      // Insert or update the superclass objects from the root down after 
      // turning off nested inserts.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(true);
        dto.setSuppressNestedPreInserts(false);
      }
      // Process any inserts for base.
      if (baseInserter != null) {
        baseInserter.insert(c, baseDtos, baseDtos.size() / 2);
      }

      // Process any updates for base.
      if (baseUpdater != null) {
        baseUpdater.update(c, baseDtos, baseDtos.size() / 2);
      }
      // Set pre-insert suppression on to suppress inserts in anything but root.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedPreInserts(true);
      }
      // Process any inserts for middle.
      if (middleInserter != null) {
        middleInserter.insert(c, middleDtos, middleDtos.size() / 2);
      }

      // Process any updates for middle.
      if (middleUpdater != null) {
        middleUpdater.update(c, middleDtos, middleDtos.size() / 2);
      }
      
      // Insert the leaf object after resetting the nested object insertion to
      // insert any nested objects connecting to any of the inserted classes.
      if (inserter != null) {
        for (com.poesys.db.dto.IDbDto dto : dtos) {
          dto.setSuppressNestedInserts(false);
        }
        inserter.insert(c, dtos, dtos.size() / 2);
      }
      
      // Update the object.
      if (updater != null) {
        updater.update(c, dtos, dtos.size() / 2);
      }
    } catch (com.poesys.db.ConstraintViolationException e) {
      rollBack(c, e.getMessage(), e);
    } catch (java.sql.SQLException e) {
      rollBack(c, e.getMessage(), e);
    } catch (com.poesys.db.BatchException e) {
      // Don't roll back the whole transaction; the DBMS rolls back the
      // individual operations that failed, but the rest should be committed.
      String message = com.poesys.db.Message.getMessage(e.getMessage(), null);
      throw new DelegateException(message, e);
    } catch (com.poesys.db.dto.DtoStatusException e) {
      String message = com.poesys.db.Message.getMessage(e.getMessage(), null);
      rollBack(c, message, e);
    } finally {
      commit(c);
      close(c);
      updateChangedToExisting(dtos);
      finalizeStatus(dtos, com.poesys.db.dto.IDbDto.Status.EXISTING);
      finalizeStatus(dtos, com.poesys.db.dto.IDbDto.Status.DELETED);
    }
  }
}
