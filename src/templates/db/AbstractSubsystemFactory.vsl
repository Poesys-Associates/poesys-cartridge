// license-header java merge-point
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractSubsystemFactory.vsl

#set ($sub = $subsystem.transformToSubsystem())
#set ($className = $sub.className)
package ${sub.fullyQualifiedName};


import java.sql.ResultSet;
import java.sql.SQLException;

import com.poesys.db.InvalidParametersException;
import com.poesys.db.pk.IPrimaryKey;


/**
 * <p>
 * A separate, shareable set of factory methods for all the ${subsystem.name}
 * classes, including JDBC data-setting, parameter-setting, and
 * primary-key-generation methods. This class is abstract and has a single
 * concrete subclass, ${sub.className}Factory, that you can modify to override
 * the default behavior in the abstract class or implement an as-yet 
 * unimplemented method.
 * </p>
$sub.documentation
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class Abstract${sub.className}Factory {
#foreach ($class in ${sub.dtos})
## Don't create a getData method for abstract classes; the query classes must
## implement the appropriate concrete subclass getters.
#if (!$class.abstractClass)
  /**
   * Retrieve the ${class.name} data from the result set's current row and create
   * a ${class.name} object.
   * 
   * @param key the primary key for the ${sub.className}
   * @param rs the query result set
   * @return a ${class.name} instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static I${class.name} get${class.name}Data(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
#foreach ($key in $class.associatedKeys)
    // Assign null to association key object, as this is set by QuerySetter
    ${key.packageName}.I${key.typeName} ${key.name}Object = null;
#end
#foreach ($attr in $class.constructorArgs)
## Use "Value" suffix to ensure name is not Java keyword; check for null
#if ($attr.supportedJdbcType)
## Call is there, assign it
    // Constructor argument ${attr.uniqueName} gets the JDBC value with a function call.
    ${attr.typeName} ${attr.uniqueName}Value = ${attr.jdbcGetCall};
#else
## Call is not there, assign default value.
#if ($attr.typeName == "java.lang.String")
    ${attr.typeName} ${attr.uniqueName}Value = "${attr.defaultValue}";
#else
    ${attr.typeName} ${attr.uniqueName}Value = ${attr.defaultValue};
#end
#end
#end
#if($class.hasLazilyLoadedMember() || $class.lazy)
    // ${class.name} has lazily loaded members or is a lazily loaded association class, so create a Proxy.
    I${class.name} newObject = 
      new ${class.name}Proxy(new ${class.name}(key#foreach ($key in $class.associatedKeys), ${key.name}Object#end#foreach ($attr in $class.constructorArgs), ${attr.uniqueName}Value#end));
#else
    // ${class.name} has no lazily loaded members, so there is no need for Proxy.
    I${class.name} newObject = 
      new ${class.name}(key#foreach ($key in $class.associatedKeys), ${key.name}Object#end#foreach ($attr in $class.constructorArgs), ${attr.uniqueName}Value#end);
#end
    return newObject;
  }
  
#end
  /**
   * <p>
   * Get a primary key for a ${class.name} based on a result set that must contain
   * the ${class.name} primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
#if ($class.abstractClass)
   * <p>
   * ${class.name} is abstract; only the getPrimaryKey method for a concrete
   * subclass may call this method to get the primary key from its superclass.
   * </p>
#end
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
#foreach ($name in ${class.stereotypeNames})
   *     <li>$name</li>
#end
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a ${class.name} ${class.keyType} primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey get${class.name}PrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
#if ($class.keyType == "NaturalKey")
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($attr in $class.keyProperties)
    ${attr.typeName} ${attr.uniqueName}Value = ${attr.jdbcGetCall}#if(${attr.required} || ${attr.typeName} == "java.lang.String");#end


    list.add(new ${attr.pkColType}(prefix + "${attr.sqlColumnName}", ${attr.uniqueName}Value));
#end
    key = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "${class.packageName}.${class.name}");
#elseif ($class.keyType == "SequenceKey")
#foreach ($attr in $class.keyProperties)
    ${attr.typeName} ${attr.uniqueName}Value = ${attr.jdbcGetCall}#if(${attr.required} || ${attr.typeName} == "java.lang.String");#end

    key = com.poesys.db.pk.PrimaryKeyFactory.createSequenceKey(prefix + "${attr.sqlColumnName}", ${attr.uniqueName}Value, "${class.packageName}.${class.name}");
#end
#elseif ($class.keyType == "GuidKey")
#foreach ($attr in $class.keyProperties)
    ${attr.typeName} ${attr.uniqueName}Value = ${attr.jdbcGetCall}#if(${attr.required} || ${attr.typeName} == "java.lang.String");#end

    key = com.poesys.db.pk.PrimaryKeyFactory.createGuidKey(prefix + "${attr.sqlColumnName}", ${attr.uniqueName}Value, "${class.packageName}.${class.name}");
#end
#elseif ($class.keyType == "IdentityKey")
#foreach ($attr in $class.keyProperties)
    ${attr.typeName} ${attr.uniqueName}Value = ${attr.jdbcGetCall}#if(${attr.required} || ${attr.typeName} == "java.lang.String");#end

    key = com.poesys.db.pk.PrimaryKeyFactory.createIdentityKey(prefix + "${attr.sqlColumnName}", ${attr.uniqueName}Value, "${class.packageName}.${class.name}");
#end
#elseif ($class.keyType == "CompositeKey")
    IPrimaryKey parentKey = get${class.compositeParent.name}PrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($attr in $class.subKeyProperties)
    ${attr.typeName} ${attr.uniqueName}Value = ${attr.jdbcGetCall}#if(${attr.required} || ${attr.typeName} == "java.lang.String");#end

    list.add(new ${attr.pkColType}(prefix + "${attr.sqlColumnName}", ${attr.uniqueName}Value));
#end
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "${class.packageName}.${class.name}");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "${class.packageName}.${class.name}");
#elseif ($class.keyType == "AssociationKey")
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
#foreach($key in $class.associatedKeys)
## Loop through associated keys and get their key properties. Construct the
## appropriate kind of IPrimaryKey for each key and combine them into the
## association key list.
    // Associated key type $key.keyType
#if ($key.keyType == "SequenceKey")
#foreach ($property in $key.keyProperties)
    // Property source: $property.source
    ${property.typeName} ${property.uniqueName}Value = ${property.jdbcGetCall}#if(${attr.required} || ${attr.typeName} == "java.lang.String");#end

    list.add(com.poesys.db.pk.PrimaryKeyFactory.createSequenceKey(prefix + "${property.sqlColumnName}", ${property.uniqueName}Value, "${class.packageName}.${class.name}"));
#end
#elseif ($key.keyType == "GuidKey")
#foreach ($property in $key.keyProperties)
    // Property source: $property.source
    ${property.typeName} ${property.uniqueName}Value = ${property.jdbcGetCall}#if(${attr.required} || ${attr.typeName} == "java.lang.String");#end

    list.add(com.poesys.db.pk.PrimaryKeyFactory.createGuidKey(prefix + "${property.sqlColumnName}", ${property.uniqueName}Value, "${class.packageName}.${class.name}"));
#end
#elseif ($key.keyType == "IdentityKey")
#foreach ($property in $key.keyProperties)
    // Property source: $property.source
    ${property.typeName} ${property.uniqueName}Value = ${property.jdbcGetCall}#if(${attr.required} || ${attr.typeName} == "java.lang.String");#end

    list.add(com.poesys.db.pk.PrimaryKeyFactory.createIdentityKey(prefix + "${property.sqlColumnName}", ${property.uniqueName}Value, "${class.packageName}.${class.name}"));
#end
#elseif ($key.keyType == "CompositeKey")
    IPrimaryKey ${key.name}Key = get${key.parentName}PrimaryKey(rs, prefix + "${key.prefix}");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> ${key.name}Keys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($property in $key.keyProperties)
    // Property source: $property.source
    ${property.typeName} ${property.uniqueName}Value = ${property.jdbcGetCall}#if(${property.required} || ${property.typeName} == "java.lang.String");#end

    
    ${key.name}Keys.add(new ${property.pkColType}(prefix + "${property.sqlColumnName}", ${property.uniqueName}Value));
#end
	IPrimaryKey ${key.name}SubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(${key.name}Keys, "${class.packageName}.${class.name}");
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(${key.name}Key, ${key.name}SubKey, "${class.packageName}.${class.name}"));
#elseif ($key.keyType == "NaturalKey")
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> ${key.name}Keys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($property in $key.keyProperties)
    // Property source: $property.source
    ${property.typeName} ${property.uniqueName}Value = ${property.jdbcGetCall}#if(${property.required} || ${property.typeName} == "java.lang.String");#end

    ${key.name}Keys.add(new ${property.pkColType}(prefix + "${property.sqlColumnName}", ${property.uniqueName}Value));
#end
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(${key.name}Keys, "${class.packageName}.${class.name}"));
#elseif ($key.keyType == "None")
## Inherited key; call the superclass getPrimaryKey method to get the key.
#if ($key.dto.superclass)
## Get the subsystem class name for the root (first) superclass in the list of superclasses.
#set ($superSubsystem = $key.dto.superclasses.get(0).subsystem.className)
#set ($root = $key.dto.superclasses.get(0).name)
    // root superclass $root
    // root superclass subsystem $superSubsystem
    list.add(${key.dto.superpackage}.${superSubsystem}Factory.get${root}PrimaryKey(rs, ""));
#end
#elseif ($key.keyType == "AssociationKey")
    // TODO Association keys for association of recursive associations like ${class.name}.${key.name} not yet supported
#end
#end
	key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "${class.packageName}.${class.name}");
#elseif ($class.keyType == "None")
## Inherited key; call the superclass getPrimaryKey method to get the key.
    // Superclass: $class.superclass.name
#if ($class.superclass)
## Get the subsystem class name for the last superclass in the list of superclasses.
#foreach ($superclass in $class.superclasses)
#set ($superSubsystem = $superclass.subsystem.className)
    // superclass $superclass.name
    // superclass subsystem $superclass.subsystem.className
#end
    key = ${class.superpackage}.${superSubsystem}Factory.get${class.superclass}PrimaryKey(rs, "");
#end
#end
    return key;
  }

  /**
   * <p>
   * Get a primary key for a ${class.name} based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
#if ($class.abstractClass)
   * <p>
   * ${class.name} is abstract; only the getPrimaryKey method for a concrete
   * subclass may call this method to get the primary key from its superclass.
   * </p>
#end
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
#foreach ($name in ${class.stereotypeNames})
   *     <li>$name</li>
#end
   * </ul>
   * 
#foreach ($attr in $class.keyProperties)
   * @param ${attr.uniqueName} ${attr.paramTag}
#end
   * @return a ${class.name} ${class.keyType} primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey get${class.name}PrimaryKey(#set ($sep = "")#foreach ($attr in $class.keyProperties)${sep}${attr.typeName} ${attr.uniqueName}#set ($sep = ", ")#end)
      throws InvalidParametersException {
    IPrimaryKey key = null;
#if ($class.keyType == "None")
#set ($keyType = $class.inheritedKeyType)
#else
#set ($keyType = $class.keyType)
#end
#if ($keyType == "NaturalKey")
## Create a variable to track whether any inputs are null, outputing a null key.
    // Track generated inputs for nullity.
    boolean noNulls = true;
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($attr in $class.keyProperties)
    if (${attr.uniqueName} != null && noNulls) {
      list.add(new ${attr.pkColType}("${attr.sqlColumnName}", ${attr.uniqueName}));
    } else {
      noNulls = false;
    }
#end
    if (noNulls) {
      key = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "${class.packageName}.${class.name}");
    }
#elseif ($keyType == "SequenceKey")
#foreach ($attr in $class.keyProperties)
    // Only create a key if the input value is present.
    if (${attr.uniqueName} != null) {
      key = com.poesys.db.pk.PrimaryKeyFactory.createSequenceKey("${attr.sqlColumnName}", ${attr.uniqueName}, "${class.packageName}.${class.name}");
    }
#end
#elseif ($keyType == "GuidKey")
#foreach ($attr in $class.keyProperties)
    // Only create a key if the input value is present.
    if (${attr.uniqueName} != null) {
      key = com.poesys.db.pk.PrimaryKeyFactory.createGuidKey("${attr.sqlColumnName}", ${attr.uniqueName}, "${class.packageName}.${class.name}");
    }
#end
#elseif ($keyType == "IdentityKey")
#foreach ($attr in $class.keyProperties)
    // Always create a key.
      key = com.poesys.db.pk.PrimaryKeyFactory.createIdentityKey("${attr.sqlColumnName}", ${attr.uniqueName}, "${class.packageName}.${class.name}");
#end
#elseif ($keyType == "CompositeKey")
    IPrimaryKey parentKey = get${class.compositeParent.name}PrimaryKey(#set ($psep = "")#foreach ($key in $class.compositeParent.keyProperties)${psep}${key.name}#set($psep = ", ")#end);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($attr in $class.subKeyProperties)
      list.add(new ${attr.pkColType}("${attr.sqlColumnName}", ${attr.uniqueName}));
#end
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "${class.packageName}.${class.name}");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "${class.packageName}.${class.name}");
    }
#elseif ($keyType == "AssociationKey")
## Create a variable to track whether any inputs are null to output a null key.
    // Track whether any input keys are null.
    boolean noNulls = true;
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
#foreach($key in $class.associatedKeys)
#if ($key.keyType == "None")
#set ($keyType = $key.getInheritedKeyType())
#else
#set ($keyType = $key.keyType)
#end
    // Associated key: $key.name with type $key.keyType
## Loop through associated keys and get their key properties. Construct the
## appropriate kind of IPrimaryKey for each key and combine them into the
## association key list.
#if ($keyType == "SequenceKey")
#foreach ($property in $key.keyProperties)
    if (${property.uniqueName} != null) {
      list.add(com.poesys.db.pk.PrimaryKeyFactory.createSequenceKey("${property.uniqueName}", ${property.uniqueName}, "${class.packageName}.${class.name}"));
    } else {
      noNulls = false;
    }
#end
#elseif ($keyType == "GuidKey")
#foreach ($property in $key.keyProperties)
    if (${property.uniqueName} != null) {
      list.add(com.poesys.db.pk.PrimaryKeyFactory.createGuidKey("${property.uniqueName}", ${property.uniqueName}, "${class.packageName}.${class.name}"));
    } else {
      noNulls = false;
    }
#end
#elseif ($keyType == "IdentityKey")
#foreach ($property in $key.keyProperties)
    if (${property.uniqueName} != null) {
      list.add(com.poesys.db.pk.PrimaryKeyFactory.createIdentityKey("${property.uniqueName}", ${property.uniqueName}, "${class.packageName}.${class.name}"));
    } else {
      noNulls = false;
    }
#end
#elseif ($keyType == "CompositeKey")
    IPrimaryKey ${key.prefix}ParentKey = get${key.parentName}PrimaryKey(#set ($psep = "")#foreach ($property in $key.parentKeyProperties)${psep}${property.uniqueName}#set($psep = ", ")#end);
    if (${key.prefix}ParentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> ${key.prefix}${key.dto.name}List =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($attr in $class.subKeyProperties)
      subkeyList.add(new ${attr.pkColType}("${attr.sqlColumnName}", ${attr.uniqueName}));
#end
	  IPrimaryKey ${key.prefix}SubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(${key.prefix}${key.dto.name}List, "${class.packageName}.${class.name}");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(${key.prefix}ParentKey, ${key.prefix}SubKey, "${class.packageName}.${class.name}");
    } else {
      noNulls = false;
    }
#elseif ($keyType == "NaturalKey")
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> ${key.name}Keys =
      new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
#foreach ($property in $key.keyProperties)
    if (${property.uniqueName} != null && noNulls) {
      ${key.name}Keys.add(new ${property.pkColType}("${property.uniqueName}", ${property.uniqueName}));
    } else {
      noNulls = false;
    }
#end
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(${key.name}Keys, "${class.packageName}.${class.name}"));
#elseif ($keyType == "AssociationKey")
    // TODO Association keys for association of recursive associations like ${class.name}.${key.name} not yet supported
#end
#end
    if (noNulls) {
	  key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "${class.packageName}.${class.name}");
	}
#end
    return key;
  }

#end
}