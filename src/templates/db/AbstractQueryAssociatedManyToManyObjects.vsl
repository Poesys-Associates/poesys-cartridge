// license-header java merge-point
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractQueryAssociatedManyToManyObjects.vsl

#set ($query = $association.transformToQuery())
#set ($subsystemName = $query.associatedDto.packageName)
#set ($subsystemPathName = $stringUtils.replace($subsystemName, ".", "/"))

## Create the query in the associated class's subsystem.
#set ($queryName = ${stringUtils.capitalize($query.name)})
package ${subsystemName}.sql;


import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import com.poesys.db.ConstraintViolationException;
import com.poesys.db.InvalidParametersException;
import com.poesys.db.dao.query.IParameterizedQuerySql;
import com.poesys.db.pk.IPrimaryKey;

#set ($dto = $query.associatedDto)
#set ($hasSubclass = $dto.subclasses.size()>0)
#set ($concreteCount = 0)
#foreach ($subclass in $dto.subclasses)
#if (!$subclass.abstractClass)
#set ($concreteCount = $concreteCount+1)
#end
#end


/**
 * <p>
 * A query Command pattern object that implements a SQL query of a collection of 
 * ${query.typeName} objects using the primary key of an associated 
 * ${query.foreignTypeName} object through the association ${query.name} using the 
 * association class ${query.associationTypeName}. This association is a many-to-many 
 * association from ${query.typeName} to ${query.foreignTypeName}.
 * </p>
 * <p>
 * This SQL specification contains a SQL statement that queries a collection of
 * ${query.typeName} objects from the database table ${query.sqlTableName} by
 * joining to the database table ${query.sqlLinkingTableName} and using the 
 * primary key from ${query.foreignTypeName} to query the collection.
 * </p>
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractQuery${queryName}By${query.foreignTypeName} 
    implements IParameterizedQuerySql<${query.packageName}.I${query.typeName}, ${query.foreignPackageName}.I${query.foreignTypeName}> {
  /** SQL query statement for ${query.sqlTableName} */
  private static final String SQL =
    "SELECT ${query.selectList} FROM ${query.manyToManyFromClause} WHERE ${query.manyToManyWhereExpr}";

  public void bindParameters(PreparedStatement stmt, ${query.foreignPackageName}.I${query.foreignTypeName} parameters)
      throws SQLException {
    // Set the parameters starting with the first parameter.
    parameters.getPrimaryKey().setParams(stmt, 1);
  }

  public String getParameterValues(${query.foreignPackageName}.I${query.foreignTypeName} parameters) {
    // Create the output string with the key parameters.
    return parameters.getPrimaryKey().getValueList();
  }

#if ($dto.abstractClass && !$hasSubclass)
  public abstract ${query.packageName}.I${query.typeName} getData(ResultSet rs) throws SQLException;
#else
  public ${query.packageName}.I${query.typeName} getData(ResultSet rs) 
      throws SQLException, ConstraintViolationException {
#if ($hasSubclass && $concreteCount>0)
    // $dto.name has subclasses, so the query returns an object of the actual
    // type rather than just of type $dto.name. It uses a discriminant expression
    // that the result set returns to figure out which class to instantiate.
    
    // Get the discriminant from the result set.
    String discriminant = rs.getString("discriminant");
    ${dto.packageName}.I${dto.name} data = null;
#foreach ($subclass in $dto.subclasses)
#if (!$subclass.abstractClass)
    // Check for $subclass.name, set return only if not already set
    if (discriminant != null && discriminant.equals("$subclass.name") && data == null) {
      // Use the ${subclass.subsystem.name} factory to get the data.
      IPrimaryKey key = 
        ${subclass.subsystem.fullyQualifiedName}.${subclass.subsystem.className}Factory.get${subclass.name}PrimaryKey(rs, "");
      data = ${subclass.subsystem.fullyQualifiedName}.${subclass.subsystem.className}Factory.get${subclass.name}Data(key, rs);
    }
#end
#end
    return data;
#else
    IPrimaryKey key = 
      ${dto.subsystem.fullyQualifiedName}.${dto.subsystem.className}Factory.get${query.typeName}PrimaryKey(rs, "");
    return ${dto.subsystem.fullyQualifiedName}.${dto.subsystem.className}Factory.get${query.typeName}Data(key, rs);
#end
  }

#end
  public IPrimaryKey getPrimaryKey(ResultSet rs) throws SQLException,
      InvalidParametersException {
    return ${subsystemName}.${dto.subsystem.className}Factory.get${query.TypeName}PrimaryKey(rs, "");
  }

  public String getSql() {
    return SQL;
  }
}