// license-header java merge-point
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDbDtoProxy.vsl

## The main data-access data-transfer object (DTO) lazy-loading proxy
#set ($dto = $class.transformToDto(null))
## Whether the objects of the class can change
package ${dto.packageName};


import org.apache.log4j.Logger;

import com.poesys.db.dto.AbstractLazyLoadingDtoProxy;


/**
 * <p>
 * A data-access layer data-transfer object (DTO) lazy-loading proxy for the 
 * ${dto.name}. This class is an abstract class that contains AndroMDA 
 * generated code; change nothing in this class. Instead, override any methods 
 * in the concrete subclass generated in the same package. AndroMDA will 
 * overwrite this class each time you run it but will never overwrite the concrete subclass.
 * </p>
${dto.documentation}
 *
 * @author Poesys/DB Cartridge
 */
public abstract class Abstract${dto.name}Proxy extends AbstractLazyLoadingDtoProxy implements I${dto.name} {
  /** Default serial version UID for the Serializable DTO */
  private static final long serialVersionUID = 1L;

  /** Logger for this class */
  private static final Logger logger = Logger.getLogger(Abstract${dto.name}Proxy.class);

  /** the deserializer used by the readObject method */
  private static final com.poesys.db.dto.Deserializer<Abstract${dto.name}Proxy> deserializer =
    new com.poesys.db.dto.Deserializer<Abstract${dto.name}Proxy>();
#if (${dto.objectProperties.size()} > 0)

  // Lazy-loading/deserialization query setter strategy nested classes for 
  // single-object associations
#end
  
#foreach($property in $dto.objectProperties)
#set ($cappedName = ${stringUtils.capitalize($property.uniqueName)})
#set ($realName = ${stringUtils.stripStart($property.className, "I")})
## Lazily loaded properties use query setters in get methods; all object properties
## use them in deserialization through the read-object setters.
  /** Flag indicating whether the ${property.uniqueName} property has been loaded */
  boolean ${property.uniqueName}Loaded = false;

  /**
   * Query setter for lazily querying nested ${property.uniqueName} object
   * (object property)
   *
   * Source: ${property.source}
   *
   * @see ${property.dto.packageName}.sql.Query${property.dto.name}
   */
  private class Query${cappedName}Setter 
      extends com.poesys.db.dto.AbstractLazyObjectSetter<${property.className}> {
    /** Serial version UID for Serializable object */
    private static final long serialVersionUID = 1L;

    /**
     * Create a Query${cappedName}Setter object.
     */
    public Query${cappedName}Setter() {
      super("${property.dto.subsystem.fullyQualifiedName}", $property.dto.expiration);
    }

    @Override
    protected String getClassName() {
      return ${property.dto.packageName}.${property.dto.name}.class.getName();
    }

    @Override
    protected com.poesys.db.pk.IPrimaryKey getKey() {
      // Generate an ${property.dto.subsystem.fullyQualifiedName}.I${property.dto.name} primary key with the value 
      // from the ${dto.subsystem.fullyQualifiedName}.I${dto.name} object
#set($fkey=$dto.getForeignKey($property.uniqueName))
      return ${property.dto.subsystem.fullyQualifiedName}.${property.dto.subsystem.className}Factory.get${property.dto.name}PrimaryKey(#set($sep="")#foreach($key in $fkey.keyProperties)${sep}((I${dto.name})dto).${key.getterName}()#set($sep=", ")#end);
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<${property.className}> getSql() {
      return new ${property.dto.packageName}.sql.Query${property.dto.name}();
    }

    @Override
    protected void set(${property.className} dto)
         throws com.poesys.db.InvalidParametersException, 
                com.poesys.db.dto.DtoStatusException {
      ${property.setterName}(dto);
    }

    @Override
    public boolean isSet() {
      // Set if proxy has loaded ${property.uniqueName}
      return ${property.uniqueName}Loaded;
    }
  }

#end
#set ($comment = "  // Setter strategy nested classes for multiple-object associations")
#foreach($property in $dto.collectionProperties)
#set ($realName = ${stringUtils.stripStart($property.className, "I")})
## Only create a lazy list query setter if the property is lazily loaded.
#if($property.lazy)
  $comment

#set($comment = "")
  /** Flag indicating whether the ${stringUtils.uncapitalize(${property.queryName})} property has been loaded */
  boolean ${stringUtils.uncapitalize(${property.queryName})}Loaded = false;

  /**
   * Query setter for lazily querying nested ${stringUtils.uncapitalize(${property.queryName})} collection
   * (collection property)
   *
   * Source: ${property.source}
   *
   * @see ${property.dto.packageName}.sql.Query${property.queryName}By${dto.name}
   */
  private class Query${property.queryName}Setter 
      extends com.poesys.db.dto.AbstractLazyListSetter<${property.className}, I${dto.name}, ${property.typeName}> {
    /** Serial version UID for Serializable object */
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = ${property.fetchSize};

    /**
     * Create a Query${property.queryName}Setter object.
     */
    public Query${property.queryName}Setter() {
      super("${property.dto.subsystem.fullyQualifiedName}", ${property.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${property.dto.packageName}.${property.dto.name}.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected I${dto.name} getParametersDto() {
      return Abstract${dto.name}Proxy.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<${property.className}, I${dto.name}> getSql() {
      return new ${property.dto.packageName}.sql.Query${property.queryName}By${dto.name}();
    }

    @Override
    protected void set(${property.typeName} collection) {
      try {
        // Register the observer parent with the subject children.
        for (${property.className} child : collection) {
          child.attach(Abstract${dto.name}Proxy.this.dto,
                              com.poesys.db.dao.DataEvent.MARKED_DELETED);
          child.attach(Abstract${dto.name}Proxy.this.dto, com.poesys.db.dao.DataEvent.DELETE);
        }
        ${property.setterName}(collection);
      } catch (com.poesys.db.dto.DtoStatusException e) {
        // Just lazy loading here, not actually setting. Ignore this exception.        
      }
    }

    @Override
    public boolean isSet() {
      // Set if proxy has loaded ${stringUtils.uncapitalize(${property.queryName})}
      return ${stringUtils.uncapitalize(${property.queryName})}Loaded;
    }
  }
#end

#if ($property.ordered)

  /**
   * Read-Object setter for de-serializing nested ${stringUtils.uncapitalize(${property.queryName})} list
   *
   * Source: ${property.source}
   *
   * @see ${dto.packageName}.sql.Query${property.dto.name}
   */
  private class Read${property.queryName}Setter 
      extends com.poesys.db.dto.AbstractListReadSetter<${property.className}> {
    private static final long serialVersionUID = 1L;

    /**
     * Create a Read${property.queryName}Setter object to read the ${property.uniqueName} list.
     */
    public Read${property.queryName}Setter() {
      super("${property.dto.subsystem.fullyQualifiedName}", ${property.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${property.dto.packageName}.${property.dto.name}.class.getName();
    }

    @Override
    protected ${property.typeName} getObjectList() {
      ${property.typeName} ${stringUtils.uncapitalize(${property.queryName})} = #if ($property.lazy)null#else ((${dto.packageName}.${dto.name})dto).get${property.queryName}()#end;
#if ($property.lazy)
      try {
        ${stringUtils.uncapitalize(${property.queryName})} = ((${dto.packageName}.${dto.name})dto).get${property.queryName}();
      } catch (java.sql.SQLException e) {
        throw new RuntimeException("SQL Exception on list query: " + e.getMessage(), e);
      }
#end
      return ${stringUtils.uncapitalize(${property.queryName})};
    }

    @Override
    protected java.util.List<com.poesys.db.pk.IPrimaryKey> getPrimaryKeys() {
      return ((${dto.packageName}.${dto.name})dto).${property.uniqueName}Keys;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<${property.className}> getSql() {
      return new ${dto.packageName}.sql.Query${property.dto.name}();
    }

    @Override
    protected void set(${property.typeName} list) {
       ${property.setterName}(list);
    }
  }
#else

  /**
   * Read-Object setter for de-serializing nested ${stringUtils.uncapitalize(${property.queryName})} collection
   *
   * Source: ${property.source}
   *
   * @see ${dto.packageName}.sql.Query${property.dto.name}
   */
  private class Read${property.queryName}Setter 
      extends com.poesys.db.dto.AbstractCollectionReadSetter<${property.className}> {
    private static final long serialVersionUID = 1L;

    /**
     * Create a Read${property.queryName}Setter object to read the ${property.uniqueName} collection.
     */
    public Read${property.queryName}Setter() {
      super("${property.dto.subsystem.fullyQualifiedName}", ${property.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${property.dto.packageName}.${property.dto.name}.class.getName();
    }

    @Override
    protected ${property.typeName} getObjectCollection() {
      ${property.typeName} ${stringUtils.uncapitalize(${property.queryName})} = #if ($property.lazy)null#else ((${dto.packageName}.${dto.name})dto).get${property.queryName}()#end;
#if ($property.lazy)
      try {
        ${stringUtils.uncapitalize(${property.queryName})} = ((${dto.packageName}.${dto.name})dto).get${property.queryName}();
      } catch (java.sql.SQLException e) {
        throw new RuntimeException("SQL Exception on collection query: " + e.getMessage(), e);
      }
#end
      return ${stringUtils.uncapitalize(${property.queryName})};
    }

    @Override
    protected java.util.List<com.poesys.db.pk.IPrimaryKey> getPrimaryKeys() {
      return ((${dto.packageName}.${dto.name})dto).${property.uniqueName}Keys;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<${property.className}> getSql() {
      return new ${dto.packageName}.sql.Query${property.dto.name}();
    }

    @Override
    protected void set(${property.typeName} collection) {
      ${property.setterName}(collection);
    }
  }
#end
## Only create add methods for read/write/mutable DTOs.
## Property is not relevant here, all add does is change the link, not the object.
#if ($dto.readWrite && !$dto.immutable)

  /**
   * Add a ${property.className} object to the ${property.queryName} collection. The method
   * loads the collection if it is not already in memory.
   *
   * add method #1 (collection property)
   *
   * Source: $property.source
   * 
   * @param object the ${property.className} object to add to the collection
#if ($property.lazy)
   * @throws java.sql.SQLException when there is a database problem
#end
   */
  ${property.visibility} void add${property.queryName}${property.dto.name}(${property.className} object)#if ($property.lazy)throws java.sql.SQLException#end {
#if ($property.lazy)
    // Collection is lazily loaded, check and load if necessary.
    if (!${stringUtils.uncapitalize(${property.queryName})}Loaded) {
      ${property.queryGetterName}();
    }
#end
    ((${dto.name})dto).add${property.queryName}${property.dto.name}(object);
  }

#end
#end  
  /**
   * Create a ${dto.name}Proxy. The concrete subclass must call this constructor.
   *
   * @param dto the DTO to proxy
   */
  public Abstract${dto.name}Proxy(${dto.name} dto) {
    super(dto);

#if ($dto.objectProperties.size() > 0 || $dto.collectionProperties.size() > 0)
    // Setter arrays
    readObjectSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
#end
#foreach($setter in $dto.collectionProperties)
## Always create read-object setters.
    readObjectSetters.add(new Read${setter.queryName}Setter());
#end

    // Add query setters for single-object deserialization.
#foreach($property in $dto.objectProperties)
#set ($cappedName = ${stringUtils.capitalize($property.uniqueName)})
    readObjectSetters.add(new Query${cappedName}Setter());
#end
  }

  /**
   * Read an object from an input stream, de-serializing it. Each generated
   * class must have this private method, which the deserialize method calls
   * through Java reflection on the specific class. The class calls a shared
   * code method to run the readObjectSetters.
   * 
   * @param in the object input stream
   * @throws ClassNotFoundException when a nested object class can't be found
   * @throws IOException when there is an IO problem reading the stream
   */
  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException,
    ClassNotFoundException {
    logger.debug("Deserializing object of class " + this.getClass().getName()
                 + " with readObject in Abstract${dto.name}Proxy");
    // Do the read-object deserialization.
    deserializer.doReadObject(in, this);
  }

  @Override
  public boolean equals(Object obj) {
    Abstract${dto.name}Proxy otherProxy = (Abstract${dto.name}Proxy)obj;
    return ((${dto.name})dto).equals(otherProxy.dto);
  }

  @Override
  public int hashCode() {
    return ((${dto.name})dto).hashCode();
  }
## Generate wrapper methods for inherited data members
#if ($dto.inheritedProperties.size() > 0)
  // Inherited properties
#end
#foreach ($property in $dto.inheritedProperties)
#if ($property.toMany)
#set ($propertyName = ${stringUtils.uncapitalize(${property.queryName})})
#set ($className = $property.queryName)
#set ($getterMethod = $property.queryGetterName)
#else
#set ($propertyName = ${property.uniqueName})
#set ($className = ${stringUtils.capitalize($property.uniqueName)})
#set ($getterMethod = $property.getterName)
#end
#if ($property.lazy)

  /** Flag indicating whether the ${propertyName} property has been loaded */
  boolean ${propertyName}Loaded = false;

## First process collections.
#if ($property.toMany)
  /**
   * Query setter for lazily querying nested ${propertyName} collection
   * (inherited to-many property)
   *
   * Source: ${property.source}
   *
   * @see ${property.dto.packageName}.sql.Query${className}By${property.inheritedFrom.name}
   */
  private class Query${className}Setter 
      extends com.poesys.db.dto.AbstractLazyListSetter<${property.className}, ${property.inheritedFrom.packageName}.I${property.inheritedFrom.name}, ${property.typeName}> {
    /** Serial version UID for Serializable object */
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = ${property.fetchSize};

    /**
     * Create a Query${className}Setter object.
     */
    public Query${className}Setter() {
      super("${property.dto.subsystem.fullyQualifiedName}", ${property.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${property.dto.packageName}.${property.dto.name}.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected I${dto.name} getParametersDto() {
      return Abstract${dto.name}Proxy.this;
    }

## Use the class name from the parent superclass that actually defines the association.
    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<${property.className}, ${property.inheritedFrom.packageName}.I${property.inheritedFrom.name}> getSql() {
      return new ${property.dto.packageName}.sql.Query${className}By${property.inheritedFrom.name}();
    }

    @Override
    protected void set(${property.typeName} collection) {
      try {
        // Register the observer parent with the subject children.
        for (${property.className} child : collection) {
          child.attach(Abstract${dto.name}Proxy.this.dto,
                              com.poesys.db.dao.DataEvent.MARKED_DELETED);
          child.attach(Abstract${dto.name}Proxy.this.dto, 
                       com.poesys.db.dao.DataEvent.DELETE);
        }
        ${property.setterName}(collection);
      } catch (com.poesys.db.dto.DtoStatusException e) {
        // Just lazy loading here, not actually setting. Ignore this exception.        
      }
    }

    @Override
    public boolean isSet() {
      // Set if proxy has loaded ${propertyName}
      return ${propertyName}Loaded;
    }
  }
## Only create add methods for read/write/mutable DTOs.
## Property is not relevant here, all add does is change the link, not the object.
#if ($dto.readWrite && !$dto.immutable)

  /**
   * Add an ${property.className} object to the ${property.queryName} collection. The method
   * loads the collection if it is not already in memory.
   *
   * add method #2 (inherited property)
   *
   * Source: $property.source
   * 
   * @param object the ${property.className} object to add to the collection
#if ($property.lazy)
   * @throws java.sql.SQLException when there is a database problem
#end
   */
  ${property.visibility} void add${property.queryName}${property.dto.name}(${property.className} object)#if ($property.lazy)throws java.sql.SQLException#end {
#if ($property.lazy)
    // Collection is lazily loaded, check and load if necessary.
    if (!${propertyName}Loaded) {
      ${getterMethod}();
    }
#end
    ((${dto.name})dto).add${className}${property.dto.name}(object);
  }

#end
## Second process objects.
#else
  /**
   * Query setter for lazily querying inherited, nested ${propertyName} object
   * (inherited object property)
   *
   * @see ${property.dto.packageName}.sql.Query${property.dto.name}()
   */
  private class Query${className}Setter 
      extends com.poesys.db.dto.AbstractLazyObjectSetter<${property.className}> {
    /** Serial version UID for Serializable object */
    private static final long serialVersionUID = 1L;

    /**
     * Create a Query${className}Setter object.
     */
    public Query${className}Setter() {
      super("${property.dto.subsystem.fullyQualifiedName}", ${property.dto.expiration});
    }

    @Override
    protected String getClassName() {
      return ${property.dto.packageName}.${property.dto.rootSuperclass}.class.getName();
    }

    @Override
    protected com.poesys.db.pk.IPrimaryKey getKey() {
      // Generate an ${property.dto.subsystem.fullyQualifiedName}.I${property.dto.name} primary key with the value 
      // from the ${dto.subsystem.fullyQualifiedName}.I${dto.name} object
#set($fkey=$property.owner.getForeignKey($property.uniqueName))
## Process to-one foreign key or to-many queried by object key
#if ($property.owner.getForeignKey($property.uniqueName))
      return ${property.dto.subsystem.fullyQualifiedName}.${property.dto.subsystem.className}Factory.get${property.dto.name}PrimaryKey(#set($sep="")#foreach($key in $fkey.keyProperties)${sep}((I${dto.name})dto).${key.getterName}()#set($sep=", ")#end);
#else
      return ${property.dto.subsystem.fullyQualifiedName}.${property.dto.subsystem.className}Factory.get${property.dto.name}PrimaryKey(#set($sep="")#foreach($key in $dto.keyProperties)${sep}((I${dto.name})dto).${key.getterName}()#set($sep=", ")#end);
#end
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<${property.className}> getSql() {
      return new ${property.dto.packageName}.sql.Query${property.dto.name}();
    }

    @Override
    protected void set(${property.className} dto)
         throws com.poesys.db.InvalidParametersException, 
                com.poesys.db.dto.DtoStatusException {
      ${property.setterName}(dto);
    }

    @Override
    public boolean isSet() {
      // Set if proxy has loaded ${propertyName}
      return ${propertyName}Loaded;
    }
  }
#end

#if ($property.toMany && $property.ordered)
#set ($collectionType = "list")
#else
#set ($collectionType = "collection")
#end
  /**
   * Get a $collectionType of ${property.className} objects, lazily loading the
   * ${propertyName}Loaded association if not already in memory
   * 
   * @return a $collectionType of ${property.className} objects
   * @throws java.sql.SQLException when there is a database problem
   */
  ${property.visibility} ${property.typeName} ${getterMethod}() throws java.sql.SQLException {
## Get the DTO that owns the property (the one from which the current DTO
## inherits the property) and get the foreign key by name.
#set($fkey=$property.owner.getForeignKey($property.uniqueName))
## Process to-one foreign key or to-many queried by object key
#if ($property.owner.getForeignKey($property.uniqueName))
    // Lazy-load the inherited ${propertyName} from the $property.owner.name 
    // if not loaded and the key $fkey.name is not null.
    if (!${propertyName}Loaded && #set($sep="")#foreach($key in $fkey.keyProperties)${sep}((I${dto.name})dto).${key.getterName}() != null#set($sep=" && ")#end) {
#else
    // Lazy-load the inherited ${propertyName} from the $property.owner.name 
    // if not loaded and the inherited key is not null.
    if (!${propertyName}Loaded && #set($sep="")#foreach($key in $dto.keyProperties)${sep}((I${dto.name})dto).${key.getterName}() != null#set($sep=" && ")#end) {
#end
      try {
        // Set as loaded, the setter will process only if this flag is set true.
        ${propertyName}Loaded = true;
        com.poesys.db.dto.ISet setter = new Query${className}Setter();
        // No connection needed for query setter
        setter.set(null);
      } catch (com.poesys.db.InvalidParametersException e) {
        throw new java.sql.SQLException(e.getMessage());
      }
    }
    return ((I${dto.name})dto).${getterMethod}();
  }
#else

  ${property.visibility} ${property.typeName} ${getterMethod}() {
    return ((I${dto.name})dto).${getterMethod}();
  }
#end
## Only output a clearer if the property is lazily loaded.
#if ($property.lazy)

  /**
   * Clear the lazily-loaded property ${propertyName}.
   */
  ${property.visibility} void clear${className}() {
    // Only clear if loaded already.
    if (${propertyName}Loaded) {
      try {
        // Call the local lazy property setter to clear the property.
        ((${dto.name})dto).${property.setterName}(null);
        ((${dto.name})dto).undoStatus();
        ${propertyName}Loaded = false;
      } catch (com.poesys.db.dto.DtoStatusException e) {
        // Couldn't set status to CHANGED, ignore because we don't want it set
      }
    }
  }
#end
## Only output a setter if the DTO and property are read/write and mutable or if the property is lazily loaded.
#if (${property.lazy} || (${dto.readWrite} && !${dto.immutable} && !${property.immutable} && ${property.readWrite}))

  /**
#if (${property.lazy})
   * Set the lazily loaded property ${propertyName} and mark it loaded.
   * 
   * @param ${propertyName} the value for the lazily loaded property
#else
   * Set the property ${propertyName}.
   * 
   * @param ${propertyName} the value for the property
#end
#if (${property.required})
   * @throws com.poesys.db.InvalidParametersException when the property value is null
#end
   */
#if (${dto.readWrite} && !${dto.immutable} && !${property.immutable} && ${property.readWrite})
  public void ${property.setterName}(${property.typeName} ${propertyName})
#else
  ${property.visibility} void ${property.setterName}(${property.typeName} ${propertyName})
#end
      #if (${property.required})throws com.poesys.db.InvalidParametersException #end{
    ((${dto.name})dto).${property.setterName}(${propertyName});
#if ($property.lazy)
    
    // Mark the property loaded and undo the status change if loading.
    if (!${propertyName}Loaded) {
      dto.undoStatus();
      ${propertyName}Loaded = true;
    }
#end
  }
#if ($property.toMany && !$property.lazy)
// Adding add method here

  /**
   * Add an ${property.className} object to the ${propertyName} collection. The method
   * loads the collection if it is not already in memory.
   *
   * add method #3 (inherited to-many)
   *
   * Source: $property.source
   * 
   * @param object the ${property.className} object to add to the collection
#if ($property.lazy)
   * @throws java.sql.SQLException when there is a database problem
#end
   */
  ${property.visibility} void add${className}${property.dto.name}(${property.className} object)#if ($property.lazy)throws java.sql.SQLException#end {
#if ($property.lazy)
    // Collection is lazily loaded, check and load if necessary.
    if (!${propertyName}Loaded) {
      ${getterMethod}();
    }
#end
    ((${dto.name})dto).add${className}${property.dto.name}(object);
  }
#end
#end
#end
## Generate wrapper methods for data members
#if ($dto.dataMembers.size() > 0)

  // Local properties (attributes, associations, and association classes)
#end
#foreach ($property in $dto.dataMembers)
#if ($property.toMany)
#set ($methodName = ${property.queryGetterName})
#set ($propertyName = ${stringUtils.uncapitalize($property.queryName)})
#set ($cappedName = ${property.queryName})
#else
#set ($methodName = ${property.getterName})
#set ($propertyName = ${property.uniqueName})
#set ($cappedName = ${stringUtils.capitalize($property.uniqueName)})
#end

#if ($property.toMany && $property.ordered)
#set ($collectionType = "a list")
#elseif ($property.toMany)
#set ($collectionType = "a collection")
#else
#set ($collectionType = "an object")
#end
  /**
   * Get ${collectionType} of ${property.className}
#if ($property.lazy)
   * loading the ${propertyName} association if it is not already in memory.
#end
   *
   * Source: $property.source
   * Lazy: $property.lazy
   * 
   * @return a ${property.typeName}
#if ($property.lazy)
   * @throws java.sql.SQLException when there is a database problem
#end
   */
  ${property.visibility} ${property.typeName} ${methodName}() #if ($property.lazy)throws java.sql.SQLException #end{
#if ($property.lazy && $dto.getForeignKey($property.uniqueName))
#set($foreignkey=$dto.getForeignKey($property.uniqueName))
    // Lazy-load the local property ${propertyName} if not loaded and the key $foreignkey.name is not null.
    if (!${propertyName}Loaded && #set($sep="")#foreach($key in $foreignkey.keyProperties)${sep}((I${dto.name})dto).${key.getterName}() != null#set($sep=" && ")#end) {
#elseif ($property.lazy)
    // Lazy-load the local property $propertyName if not loaded.
    if (!${propertyName}Loaded) {
#end
#if ($property.lazy)
      try {
        com.poesys.db.dto.ISet setter = new Query${cappedName}Setter();
        // Set as loaded, the setter will process only if this flag is set true.
        ${propertyName}Loaded = true;
        // No connection needed for query setter
        setter.set(null);
      } catch (com.poesys.db.InvalidParametersException e) {
        throw new java.sql.SQLException(e.getMessage());
      }
    }#if ($property.required && $dto.getForeignKey($property.uniqueName)) else if (!${propertyName}Loaded) {
      // ${foreignkey.name} key attribute is null but is required
      java.util.List<String> args = new java.util.ArrayList<String>(1);
      args.add("${foreignkey.name}");
      com.poesys.db.NoRequiredValueException e = 
        new com.poesys.db.NoRequiredValueException("com.poesys.db.dto.msg.lazy_load_no_required_value");
      e.setParameters(args);
      throw e;
    }
#end

#end
    return ((${dto.name})dto).${methodName}();
  }
## Only output a clearer if the property is lazily loaded.
#if ($property.lazy)

  /**
   * Clear the lazily loaded property ${propertyName} if it is loaded.
   */
  ${property.visibility} void clear${stringUtils.capitalize(${propertyName})}() {
    // Only clear if loaded already.
    if (${propertyName}Loaded) {
      try {
        // Call the local lazy property setter to clear the property.
        ((${dto.name})dto).${property.setterName}(null);
        ((${dto.name})dto).undoStatus();
        ${propertyName}Loaded = false;
      } catch (com.poesys.db.dto.DtoStatusException e) {
        // Couldn't set status to CHANGED, ignore because we don't want it set
      }
    }
  }

#end
  /**
   * Set the ${propertyName} from a lazy-loading proxy, either for lazily 
   * loading the data or deserializing nested objects. The IDbDto-derived 
   * interface does not contain this method.
   *
   * @param ${propertyName} the lazily loaded value to assign
#if (${property.required})
   * @throws com.poesys.db.InvalidParametersException when the property value is null
#end
   */
 #if(${property.readWrite}) ${property.visibility}#end void ${property.setterName}(${property.typeName} ${propertyName})
      #if (${property.required})throws com.poesys.db.InvalidParametersException #end{
    ((${dto.name})dto).${property.setterName}(${propertyName});
#if ($property.lazy)
    // Mark the property loaded and undo the status change.
    dto.undoStatus();
    ${propertyName}Loaded = true;
#end
  }
#end

  public void markChildrenDeleted() throws com.poesys.db.dto.DtoStatusException {
  	((${dto.name})dto).markChildrenDeleted();
  }
}