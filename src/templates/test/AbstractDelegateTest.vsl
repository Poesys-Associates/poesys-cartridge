// license-header java merge-point
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDelegateTest.vsl

## The main data-transfer object (DTO)
#set ($dto = $class.transformToDto(null))
#set ($subsystem = $dto.subsystem)
#set ($businessPackageName = $subsystem.businessPackageName)
## used in catalog.xml for directory name
#set ($businessPackageDir = ${stringUtils.replace($businessPackageName, ".", "/")})
package ${businessPackageName};


import static org.junit.Assert.assertTrue;

#set ($addFail = false)
#foreach ($var in $dto.objectProperties)
#if ($var.lazy && !$var.required)
## Needs fail imported for optional test
#set ($addFail = true)
#end
#end
#if ($addFail)
import static org.junit.Assert.fail;
#end

import java.util.List;
#if ($dto.readWrite)
import java.util.concurrent.CopyOnWriteArrayList;
#end

import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;

import com.poesys.bs.delegate.DelegateException;
import com.poesys.db.InvalidParametersException;
import com.poesys.db.dao.DaoManagerFactory;
import com.poesys.db.dao.IDaoManager;


/**
 * <p>
 * Test the ${dto.name}Delegate class.
 * </p>
 * <p>
 * Note that all the test cases defined here run independently, because JUnit
 * does not guarantee the execution order of the test cases in any way.
 * </p>
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class Abstract${dto.name}DelegateTest {
  /** Define a class logger. */
  protected static Logger logger = Logger.getLogger(Abstract${dto.name}DelegateTest.class);
  /** Subsystem name in database.properties file */
  protected String subsystem = "${subsystem.fullyQualifiedName}";
  /** Boolean saved off for later comparison in update tests */
  protected Boolean originalBooleanValue = null;
  /** Delegate created at class level for sharing between methods */
  protected ${dto.name}Delegate delegate = null;

  /**
   * Set up the test by creating the class under test (CUT).
   * 
   * @throws InvalidParametersException when an invalid parameter prevents the
   *       creation of an object
   * @throws DelegateException when a problem occurs during object creation
   */
  @Before
  public void setUp() {
    delegate = ${dto.subsystem.className}DelegateFactory.get${dto.name}Delegate();
    // Clear any existing caches of objects using the memory manager set in
    // the creation of the delegate.
    clearCaches();
    assertTrue("No delegate created", delegate != null);
  }
  
  /**
   * Helper method to clear caches for any objects used in the test
   */
  protected void clearCaches() {
#if ($dto.hasLazilyLoadedMember())
    // Primary class ${dto.name}Proxy cache
    IDaoManager manager = DaoManagerFactory.getManager(getSubsystem());
    if (manager != null) {
      manager.clearCache(${dto.packageName}.${dto.name}Proxy.class.getName());
    }
#else
    // Primary class ${dto.name} cache
    IDaoManager manager = DaoManagerFactory.getManager(getSubsystem());
    if (manager != null) {
      manager.clearCache(${dto.packageName}.${dto.name}.class.getName());
    }
#end
#if ($dto.childDtos.size() > 0)

    // Clear nested object caches
#foreach ($child in $dto.childDtos)
    
#if ($child.hasLazilyLoadedMember())
    // Child $child.name Proxy cache
    IDaoManager ${child.name}Manager = DaoManagerFactory.getManager("${child.subsystem.fullyQualifiedName}");
    if (${child.name}Manager != null) {
      ${child.name}Manager.clearCache(${child.packageName}.${child.name}.class.getName());
    }
#else
    // Child $child.name cache
    IDaoManager ${child.name}Manager = DaoManagerFactory.getManager("${child.subsystem.fullyQualifiedName}");
    if (${child.name}Manager != null) {
      ${child.name}Manager.clearCache(${child.packageName}.${child.name}.class.getName());
    }
#end
#end
#end
  }
## Generate a create method for the non-Integer required object properties.
#foreach ($property in $dto.testVars)
#if ($property.associationEnd && $property.typeName != "java.math.BigInteger" && $property.required)

  /**
   * Get a test object for the create method for the $dto.name property 
   * ${property.name}. 
   *
   * This is abstract; the generated modifiable class must implement this method.
   *
   * @param objectNumber the sequential counter that identifies the object to
   *                     return a key for in the implementation
   * @return ${property.typename} key value
   */
  abstract protected List<Bs${property.dto.name}> create${stringUtils.capitalize($property.uniqueName)}${property.dto.name}(int objectNumber);
#end
#end
## Only add create helper if the class is writable (insertable).
#if ($dto.readWrite)

  /**
   * Create some number of new ${dto.name} objects and return them in a list.  
   * This is a helper method for writable children DTOs.
   * 
   * @param count the number of objects to create
   * @return the stored object
   * @throws InvalidParametersException when an invalid parameter prevents the
   *       creation of an object
   * @throws DelegateException when a problem occurs during object creation
   */
  protected List<${dto.subsystem.businessPackageName}.Bs${dto.name}> create${dto.uniqueName}(int count) 
      throws DelegateException, InvalidParametersException {
    List<${dto.subsystem.businessPackageName}.Bs${dto.name}> objects = 
      new CopyOnWriteArrayList<${dto.subsystem.businessPackageName}.Bs${dto.name}>();
    @SuppressWarnings("unused")
    java.util.Random r = new java.util.Random();
## Foreign keys are association key components or composite sub-keys; create
## a create() method for each such foreign key that is required but is not 
## itself a key of the DTO class.
#foreach ($key in $dto.foreignKeys)
#if ($key.required && !$key.key)

#if ($key.readWrite && !$dto.immutable)
    // Create the required ${key.uniqueTypeName} objects.
#else
    // Query the required ${key.uniqueTypeName} objects.
#end
#set ($varName = ${stringUtils.uncapitalize($key.uniqueTypeName)})
    List<${key.businessPackageName}.Bs${key.typeName}> ${varName}Objects = create${key.uniqueTypeName}(count);    
#end
#end
## Create a null object for any required, transient objects associated to the class.
#foreach($property in $dto.constructorArgs)
#if ($property.required && !$property.sqlPrimitive)
## Required and no JDBC get call present, meaning it's transient

    // Create the required ${property.typeName} variable as null.
    ${property.typeName} ${property.uniqueName} = null;
#end
#end
    
    for (int i = 0; i < count; i++) {
#foreach ($key in $dto.foreignKeys)
#set ($varName = ${stringUtils.uncapitalize($key.uniqueTypeName)})
#foreach ($property in $key.keyProperties)
#if ($key.required && !$key.key)
      ${property.typeName} ${property.uniqueName} = ${varName}Objects.get(i).get${stringUtils.capitalize($property.originalName)}();
#elseif ($key.key && !$key.generalization)
## Primary key in current class but not inherited through generalization, so explicit on foreign key.
      // $property.uniqueName is a foreign key that serves as a primary key for the $dto.name.
      // Get the foreign key property value from a lookup method in the concrete class.
      ${property.typeName} ${property.uniqueName} = getTestKey${stringUtils.capitalize($property.uniqueName)}(i);
#elseif (!$key.key)
      // Create a null variable for the ${key.typeName}, which is not required.
      ${property.typeName} ${property.uniqueName} = null;
#end
#end
#end
#foreach ($property in $dto.testVars)
## First handle nested objects (associations).
#if ($property.associationEnd)
      // Nested object 
      // Source: $property.source
#if ($property.typeName == "java.math.BigInteger")
## Set property to null if key and dto is IdentityKey, SequenceKey, or GuidKey
#if ($dto.keyType == "None")
#set ($keyType = $dto.inheritedKeyType)
#else
#set ($keyType = $dto.keyType)
#end
#if ($dto.readWrite && ($keyType == "IdentityKey" || $keyType == "SequenceKey" || $keyType == "GuidKey"))
      ${property.typeName} ${property.uniqueName} = null;
#elseif (!$dto.readWrite))
      ${property.typeName} ${property.uniqueName} = getTestKey${stringUtils.capitalize($property.uniqueName)}(i);
#else
      // Source: $property.source
      ${property.typeName} ${property.uniqueName} = 
        new java.math.BigInteger(new Long(r.nextLong()).toString());
#end
#elseif ($property.required)
      ${property.typeName} ${property.uniqueName} = create${stringUtils.capitalize($property.uniqueName)}${property.dto.name}(count).get(i).get${stringUtils.capitalize($property.originalName)}();
#else
      // Create a null variable for the ${key.typeName}, which is not required.
      ${property.typeName} ${property.uniqueName} = null;
#end
#elseif ($property.typeName == "java.lang.String")
      ${property.typeName} ${property.uniqueName} = 
#if ($property.length)
        com.poesys.cartridges.db.utilities.StringUtilities.generateString(${property.length});
#else
        com.poesys.cartridges.db.utilities.StringUtilities.generateString();
#end
#elseif ($property.typeName == "java.util.Date")
      ${property.typeName} ${property.uniqueName} = new java.util.Date(r.nextLong());
#elseif ($property.typeName == "java.sql.Timestamp")
      // Use random integer here because long might be out of range.
      ${property.typeName} ${property.uniqueName} = new java.sql.Timestamp(r.nextInt(999999999));
#elseif ($property.typeName == "short")
      ${property.typeName} ${property.uniqueName} = (short)r.nextInt(99999);
#elseif ($property.typeName == "java.lang.Short")
      ${property.typeName} ${property.uniqueName} = (short)r.nextInt(99999);
#elseif ($property.typeName == "int")
      ${property.typeName} ${property.uniqueName} = r.nextInt(999999999);
#elseif ($property.typeName == "java.lang.Integer")
      ${property.typeName} ${property.uniqueName} = r.nextInt(999999999);
#elseif ($property.typeName == "long")
      ${property.typeName} ${property.uniqueName} = r.nextLong();
#elseif ($property.typeName == "java.lang.Long")
      ${property.typeName} ${property.uniqueName} = r.nextLong();
#elseif ($property.typeName == "float")
      ${property.typeName} ${property.uniqueName} = r.nextFloat();
#elseif ($property.typeName == "java.lang.Float")
      ${property.typeName} ${property.uniqueName} = r.nextFloat();
#elseif ($property.typeName == "double")
      ${property.typeName} ${property.uniqueName} = r.nextDouble();
#elseif ($property.typeName == "java.lang.Double")
      ${property.typeName} ${property.uniqueName} = r.nextDouble();
#elseif ($property.typeName == "boolean")
      ${property.typeName} ${property.uniqueName} = r.nextBoolean();
#elseif ($property.typeName == "java.lang.Boolean")
      ${property.typeName} ${property.uniqueName} = r.nextBoolean();
#set ($done = true)
#elseif ($property.typeName == "java.math.BigInteger")
## Set property to null if key and dto is IdentityKey, SequenceKey, or GuidKey
#if ($dto.keyType == "None")
#set ($keyType = $dto.inheritedKeyType)
#else
#set ($keyType = $dto.keyType)
#end
#if ($dto.readWrite && ($keyType == "IdentityKey" || $keyType == "SequenceKey" || $keyType == "GuidKey") && $property.key)
      ${property.typeName} ${property.uniqueName} = null;
#elseif (!$dto.readWrite && $property.key)
      ${property.typeName} ${property.uniqueName} = getTestKey${stringUtils.capitalize($property.uniqueName)}(i);
#else
      ${property.typeName} ${property.uniqueName} = 
        new java.math.BigInteger(new Long(r.nextLong()).toString());
#end
#elseif ($property.typeName == "java.math.BigDecimal")
      ${property.typeName} ${property.uniqueName} = 
        new java.math.BigDecimal(new Double(r.nextDouble()).toString());
#else
## A transient class, create a null object.
      ${property.typeName} ${property.uniqueName} = null;
#end
#end

#set ($sep = "")
      // Create the object.
      Bs${dto.name} object = null;
      try {
        object = delegate.create${dto.name}(#foreach ($property in $dto.constructorArgs)${sep}${property.uniqueName}#set ($sep = ", ")#end);
#foreach ($key in $dto.foreignKeys)
#if ($key.required && !$key.key && $dto.readWrite && !$dto.immutable)
#set ($varName = ${stringUtils.uncapitalize($key.uniqueTypeName)})
#set ($setterName = ${stringUtils.capitalize($key.name)})
        // Add any required nested ${key.typeName} object.
        object.set${setterName}(${varName}Objects.get(i));
#end
#end
      } catch (InvalidParametersException e) {
        Object[] args = e.getParameters().toArray();
        String message = com.poesys.db.Message.getMessage(e.getMessage(), args);
        throw new RuntimeException(message, e);
      } catch (DelegateException e) {
        throw new RuntimeException(e.getMessage(), e);
      }
        
      objects.add(object);
    }
    
    return objects;
  }
#end
#foreach ($key in $dto.foreignKeys)
#foreach ($property in $key.keyProperties)
## Produce method only for foreign keys that are also primary keys for the DTO.
## Ignore inherited keys, which are covered by the following read-only code.
#if ($property.key && !$key.generalization)

  /**
   * Get a test key for the primary key. This is abstract; the generated
   * modifiable class ${dto.name}DelegateTest must implement this method for 
   * the read-write class ${dto.name} that has a foreign key ($key.name) as part
   * of its primary key.
   *
   * @param objectNumber the sequential counter that identifies the object to
   *                     return a key for in the implementation
   */
  abstract protected ${property.typeName} getTestKey${stringUtils.capitalize($property.uniqueName)}(int objectNumber);
#end
#end
#end
## Check for natural keys for read-only DTOs.
#if (!$dto.readWrite)
#foreach ($property in $dto.testVars)
#if ($property.key)

  /**
   * Get a test key for the create method or primary key for a ${dto.name}. 
   * This is abstract; the generated modifiable class must implement this method
   * for read-only classes.
   *
   * @param objectNumber the sequential counter that identifies the object to
   *                     return a key for in the implementation
   * @return ${property.typename} key value
   */
  abstract protected ${property.typeName} getTestKey${stringUtils.capitalize($property.uniqueName)}(int objectNumber);
#end
#end
#end

#foreach($childDto in $dto.childDtos)
## Get any inherited key type.
#if ($childDto.keyType == "None")
#set ($keyType = $childDto.inheritedKeyType)
#else
#set ($keyType = $childDto.keyType)
#end
## Produce methods only for read/write classes.
#if ($dto.readWrite && $childDto.readWrite)
  /**
   * <p>
   * Create some number of new ${childDto.name} objects and return them in a list.  
   * This is a helper method that the concrete subclass needs to implement. It
   * returns a child object.
   * </p>
   * <ul>
   * <li>Create the list to return as a CopyOnWriteArrayList&lt;Bs${childDto.name}&gt;</li>
#if ($keyType == "CompositeKey")
   * <li>Generate any required objects linked to this object other than the 
   * parent by calling the appropriate delegate's create method</li>
   * <li>Create the sub-key as an integer for ordered subkeys or a random string
   * for unordered subkeys</li>
#elseif ($keyType == "AssociationKey")
   * <li>Generate any required objects linked to this object other than the 
   * associated objects by calling the appropriate delegate's create method</li>
#end
   * <li>Generate random values for any primitive data members</li>
   * <li>Create the Bs${childDto.name} by calling delegate.createBs${childDto.name}</li>
   * <li>Add the new child to the list</li>
   * </ul>
   * <p>
   * Key type: $keyType
   * </p>
#if ($keyType == "AssociationKey")
#foreach ($key in $childDto.associatedKeys)
   * @param ${key.prefix}List a list of source objects to link with at least the number
   *                 of objects required by count
#end
#else
   * @param parent the parent ${dto.name}
#end
   * @param count the number of objects to create
   * @return the stored object
   * @throws DelegateException when there is a problem creating an object
   * @throws InvalidParametersException when there is some problem with the 
   *                                    input parameters for creating an object
   */
#if ($keyType == "AssociationKey")
#set ($sep="")
  abstract protected List<${childDto.subsystem.businessPackageName}.Bs${childDto.name}> create${childDto.uniqueName}(#foreach ($key in $childDto.associatedKeys)${sep}List<${key.packageName}.I${key.typeName}> ${key.prefix}List#set ($sep=", ")#end, int count) 
      throws DelegateException, InvalidParametersException; // create 1

#else
  abstract protected List<${childDto.subsystem.businessPackageName}.Bs${childDto.name}> create${childDto.uniqueName}(${dto.packageName}.I${dto.name} parent, 
                                                       int count) 
      throws DelegateException, InvalidParametersException; // create 2
      
#end
#end
#end
#foreach($key in $dto.foreignKeys)
## Proceed only for non-inheritance foreign keys
#if (!$key.generalization)
  /**
   * <p>
   * Create some number of new ${key.typeName} objects and return them in a list.  
   * This is a helper method that the concrete subclass needs to implement. It
   * returns the "child" corresponding to the superclass.
   * </p>
   * <ul>
   * <li>Create the list to return as a CopyOnWriteArrayList&lt;Bs${key.typeName}&gt;</li>
#if ($key.keyType == "CompositeKey")
   * <li>Generate any required objects linked to this object other than the 
   * parent by calling the appropriate delegate's create method</li>
   * <li>Create the sub-key as an integer for ordered subkeys or a random string
   * for unordered subkeys</li>
#elseif ($key.keyType == "AssociationKey")
   * <li>Generate any required objects linked to this object other than the 
   * associated objects by calling the appropriate delegate's create method</li>
#end
   * <li>Generate random values for any primitive data members</li>
   * <li>Create the Bs${key.typeName} by calling delegate.createBs${foreignDto.name}</li>
   * <li>Add the new child to the list</li>
   * </ul>
   * <p>
   * Key type: $key.keyType
   * </p>
#if ($key.keyType == "CompositeKey")
   * @param parent the parent ${dto.name}
#elseif ($key.keyType == "AssociationKey")
   * @param objects1 a list of source objects to link with at least the number
   *                 of objects required by count
   * @param objects2 a list of target objects to link with at least the number
   *                 of objects required by count
#end
   * @param count the number of objects to create
   * @return the stored object
   * @throws DelegateException when there is a problem creating an object
   * @throws InvalidParametersException when there is some problem with the 
   *                                    input parameters for creating an object
   */
#if ($key.keyType == "AssociationKey")
#set ($dto1 = $key.getKeyProperties().get(0).getDto())
#set ($dto2 = $key.getKeyProperties().get(1).getDto())
  abstract protected List<${key.businessPackageName}.Bs${key.typeName}> create${key.uniqueTypeName}(List<${dto1.packageName}.I${dto1.name}> objects1, 
                                                       List<${dto2.packageName}.I${dto2.name}> objects2, 
                                                       int count) 
      throws DelegateException, InvalidParametersException; // create 3

#else
  abstract protected List<${key.businessPackageName}.Bs${key.typeName}> create${key.uniqueTypeName}(int count) 
      throws DelegateException, InvalidParametersException; // create 4
      
#end
#end
#end
#if ($dto.readWrite)
  /**
   * Test method for delegate insert
   */
  @Test
  public void testInsert() {
    // Create a new ${dto.name} object to perform the test.
    List<Bs${dto.name}> objects = create${dto.uniqueName}(1);
    assertTrue("No object created", objects.get(0) != null);
    delegate.insert(objects);
    ${dto.keyClass} key = 
      (${dto.keyClass})objects.get(0).getPrimaryKey();
    assertTrue("No key for inserted object", key != null);

    Bs${dto.name} queriedObject = queryStoredObject(key);
    assertTrue("No queried inserted object", queriedObject != null);
    assertTrue("Wrong object", objects.get(0).equals(queriedObject));
#if ($dto.readWrite)
    // Delete the inserted objects to clean up.
    // Mark all the objects for delete.
    for (Bs${dto.name} object : objects) {
      object.delete();
    }

    delegate.deleteBatch(objects);
#end
  }
#end

  /**
   * Test method for getObject
   * 
   * @throws java.sql.SQLException when there is a problem querying a collection 
   *                               property
   */
  @Test
  public void testGetObject() throws java.sql.SQLException {
## Get the key type and handle inherited keys.
#if ($dto.keyType.equals("None"))
#set ($keyType = $dto.inheritedKeyType)
#else
#set ($keyType = $dto.keyType)
#end
##Set the appropriate class name.
#if ($keyType == "NaturalKey")
#set($keyClass = "com.poesys.db.pk.NaturalPrimaryKey")
#elseif ($keyType == "SequenceKey")
#set($keyClass = "com.poesys.db.pk.SequencePrimaryKey")
#elseif ($keyType == "IdentityKey")
#set($keyClass = "com.poesys.db.pk.IdentityPrimaryKey")
#elseif ($keyType == "GuidKey")
#set($keyClass = "com.poesys.db.pk.GuidPrimaryKey")
#elseif ($keyType == "CompositeKey")
#set($keyClass = "com.poesys.db.pk.CompositePrimaryKey")
#elseif ($keyType == "AssociationKey")
#set($keyClass = "com.poesys.db.pk.AssociationPrimaryKey")
#end
## If this DTO is read/write, create a new object, insert it, and extract the
## key. Otherwise, create a key based on an abstract method call getTestKey that
## the developer overrides in the concrete class. The key type is the fully
## qualified Poesys/DB primary key class.
#if ($dto.readWrite)
    // Create a new ${dto.name} object to perform the test.
    List<Bs${dto.name}> objects = create${dto.uniqueName}(1);
    assertTrue("No object created", objects.get(0) != null);
    delegate.insert(objects);
    ${dto.keyClass} key = 
      (${dto.keyClass})objects.get(0).getPrimaryKey();
#else
    // Get the ${keyType} by using the key factory,
    // supplying the appropriate key attributes using
    // test accessor methods. 
    ${keyClass} key = 
      (${keyClass})${dto.subsystem.fullyQualifiedName}.${dto.subsystem.className}Factory.get${dto.name}PrimaryKey(#set($sep="")#foreach ($key in $dto.keyProperties)${sep}getTestKey${stringUtils.capitalize($key.uniqueName)}(0)#set($sep=", ")#end);
#end
    assertTrue("No key generated from concrete implementation", key != null);
#if ($dto.readWrite)
    Bs${dto.name} insertedObject = objects.get(0);
    assertTrue("No comparison object for object query", insertedObject != null);
#end
    
    // Query the object.
    Bs${dto.name} object = delegate.getObject(key);
    assertTrue("Couldn't get object", object != null);
#if ($dto.readWrite)
    assertTrue("Wrong object", insertedObject.equals(object));
#end
#foreach ($var in $dto.objectProperties)
#if ($var.lazy)
    
#if ($var.required)
    // Testing lazy loading of $var.uniqueName object property
    ${var.bsTypeName} ${var.uniqueName} = object.${var.getterName}();
    assertTrue("${var.uniqueName} not lazily loaded", ${var.uniqueName} != null);
#else
    // Testing lazy loading of optional $var.uniqueName object property
    try {
      @SuppressWarnings("unused")
      ${var.bsTypeName} ${var.uniqueName} = object.${var.getterName}();
      assertTrue( true);
    } catch (Throwable e) {
      fail(e.getMessage());
    }
#end
#end
#end
#foreach ($var in $dto.collectionProperties)
#if ($var.lazy)
#if ($property.ordered)
#set ($collectionType = "List")
#set ($fullCollectionType = "java.util.List")
#else
#set ($collectionType = "Collection")
#set ($fullCollectionType = "java.util.Collection")
#end
    
    // Testing lazy loading of ${stringUtils.uncapitalize(${var.queryName})} ${collectionType} property
    ${fullCollectionType}<${var.bsTypeName}> ${stringUtils.uncapitalize(${var.queryName})} = 
      object.${var.queryGetterName}();
    assertTrue("${var.uniqueName} not lazily loaded", ${stringUtils.uncapitalize(${var.queryName})} != null);
#end
#end
#if ($dto.readWrite)
    // Delete the inserted objects to clean up.
    // Mark all the objects for delete.
    for (Bs${dto.name} o : objects) {
      o.delete();
    }

    delegate.deleteBatch(objects);
#end
  }

  /**
   * <p>
   * Test method for getAllObjects
   * </p>
#if ($dto.readWrite)
   * <p>
   * For this read/write class, the method ensures that there are objects to
   * query by inserting an object, querying, then deleting the object.
   * </p>
#end
   *
   * @throws InvalidParametersException when an invalid parameter prevents the
   *       creation of an object
   * @throws DelegateException when a problem occurs during object creation
   */
  @Test
  public void testGetAllObjects() 
       throws InvalidParametersException, DelegateException {
#if ($dto.readWrite)
    // Create a new ${dto.name} object to perform the test.
    List<Bs${dto.name}> insertedObjects = create${dto.uniqueName}(1);
    assertTrue("No object created", insertedObjects.get(0) != null);
    delegate.insert(insertedObjects);
    
#end
    // Query all the objects.
    List<Bs${dto.name}> objects = delegate.getAllObjects(100);
    assertTrue("Couldn't create list", objects != null);
    // The list should not be empty.
    assertTrue("List of all objects empty", objects.size() != 0);
#if ($dto.readWrite)
    // Delete the inserted objects to clean up.
    // Mark all the objects for delete.
    for (Bs${dto.name} o : insertedObjects) {
      o.delete();
    }

    delegate.deleteBatch(insertedObjects);
#end
  }

  /**
   * A helper method that queried a previously stored object identified by its
   * primary key. The method returns the queried object for further testing
   * after performing structural tests on the object.
   * 
   * @param key the primary key of the object to retrieve
   * @return the object
   * @throws DelegateException when there is a problem querying the object
   */
  protected Bs${dto.name} queryStoredObject(${dto.keyClass} key)
      throws DelegateException {
    // Clear the caches, then query the saved object and test it.
    clearCaches();

    Bs${dto.name} queriedObject = delegate.getDatabaseObject(key);
    assertTrue("Object not found", queriedObject != null);
    return queriedObject;
  }
## Only need exists() helper if read/write
#if ($dto.readWrite)

  /**
   * A helper method that tests the stored existence of the object identified
   * by the pre-existing, saved primary key.
   * 
   * @param key the primary key (${dto.keyClass}) of the object to check
   * @return true if the object is in the database, false if not
   * @throws DelegateException when there is a problem querying the object
   */
  protected boolean exists(${dto.keyClass} key) throws DelegateException {
    // Clear the caches, then query the saved object and test it.
    clearCaches();

    Bs${dto.name} queriedObject = delegate.getObject(key);
    return queriedObject != null;
  }
#end
#if (!$dto.immutable && $dto.readWrite)

  /**
   * Test the updating of the inserted object.
   */
  @Test
  public void testUpdate() {
    // Create a new ${dto.name} object to perform the test.
    List<Bs${dto.name}> objects = create${dto.uniqueName}(1);
    assertTrue("No object created", objects.get(0) != null);
    delegate.insert(objects);
    ${dto.keyClass} key = 
      (${dto.keyClass})objects.get(0).getPrimaryKey();
    assertTrue("No key for inserted object", key != null);
    Bs${dto.name} insertedObject = objects.get(0);
    assertTrue("No created object to update", insertedObject != null);
    
    // Update the inserted object and query it to test.
    updateColumn(insertedObject);
    delegate.update(insertedObject);
    Bs${dto.name} queriedObject = queryStoredObject(key);
    assertTrue("Object not updated", isColumnUpdated(queriedObject));
#if ($dto.readWrite)
    // Delete the inserted objects to clean up.
    // Mark all the objects for delete.
    for (Bs${dto.name} object : objects) {
      object.delete();
    }

    delegate.deleteBatch(objects);
#end
  }
  
  /**
   * Update the first mutable column with a new value.
   *
   * @param object the Bs${dto.name} object to update
   */
  protected void updateColumn(Bs${dto.name} object) {
#set ($done = false)
#foreach ($col in $dto.columns)
#if (!$done && $col.readWrite && !$col.immutable)
#if ($col.typeName == "java.lang.String")
    try {
#if ($col.length)
      object.${col.setterName}("${dto.name}.${col.name} updated".substring(0, "${dto.name}.${col.name} updated".length() < $col.length ? "${dto.name}.${col.name} updated".length() : $col.length));
#else 
      object.${col.setterName}("${dto.name}.${col.name} updated");
#end
#set ($done = true)
#elseif ($col.typeName == "java.util.Date")
    try {
      java.text.SimpleDateFormat format = 
        new java.text.SimpleDateFormat("M/d/yyyy");
      try {
        java.util.Date date = format.parse("5/14/2009");
        object.${col.setterName}(date);
      } catch (java.text.ParseException e) {
        assertTrue("Invalid date", false);      
      }
#set ($done = true)
#elseif ($col.typeName == "java.sql.Timestamp")
    try {
      java.text.SimpleDateFormat format = 
        new java.text.SimpleDateFormat("M/d/yyyy HH:mm:ss");
      try {
        object.${col.setterName}(new java.sql.Timestamp(format.parse("5/14/2009 10:55:30").getTime()));
      } catch (java.text.ParseException e) {
        assertTrue("Invalid timestamp", false);      
      }
#set ($done = true)
#elseif ($col.typeName == "short")
    try {
      object.${col.setterName}(5);
#set ($done = true)
#elseif ($col.typeName == "java.lang.Short")
    try {
      object.${col.setterName}(5);
#set ($done = true)
#elseif ($col.typeName == "int")
    try {
      object.${col.setterName}(123);
#set ($done = true)
#elseif ($col.typeName == "java.lang.Integer")
    try {
      object.${col.setterName}(123);
#set ($done = true)
#elseif ($col.typeName == "long")
    try {
      object.${col.setterName}(456L);
#set ($done = true)
#elseif ($col.typeName == "java.lang.Long")
    try {
      object.${col.setterName}(456L);
#set ($done = true)
#elseif ($col.typeName == "float")
    try {
      object.${col.setterName}(123.456);
#set ($done = true)
#elseif ($col.typeName == "java.lang.Float")
    try {
      object.${col.setterName}(123.456);
#set ($done = true)
#elseif ($col.typeName == "double")
    try {
      object.${col.setterName}(123.456);
#set ($done = true)
#elseif ($col.typeName == "java.lang.Double")
    try {
      object.${col.setterName}(123.456);
#set ($done = true)
#elseif ($col.typeName == "boolean")
    try {
      originalBooleanValue = object.${col.getterName}();
      object.${col.setterName}(!(object.${col.getterName}()));
#set ($done = true)
#elseif ($col.typeName == "java.lang.Boolean")
    try {
      originalBooleanValue = object.${col.getterName}();
      object.${col.setterName}(!(object.${col.getterName}()));
#set ($done = true)
#elseif ($col.typeName == "java.math.BigInteger")
    try {
      object.${col.setterName}(new java.math.BigInteger("123456789"));
#set ($done = true)
#elseif ($col.typeName == "java.math.BigDecimal")
    try {
      object.${col.setterName}(new java.math.BigDecimal("12345.6789"));
#set ($done = true)
#end
## only the above types will get updated
#if ($done)
## Wrote an update line above, so finish the try block
    } catch (com.poesys.db.dto.DtoStatusException e) {
      org.junit.Assert.fail(e.getMessage());
    }
#else
    // No field to update, nothing done
#end
#end
#end
  }

  /**
   * Is the appropriate column in the input object set to the update value?
   *
   * @param object the Bs${dto.name} object to update
   * @return true if the column is updated, false if not
   * @see #updateColumn
   */
  protected boolean isColumnUpdated(Bs${dto.name} object) {
    boolean retVal = false;
#set ($done = false)
#foreach ($col in $dto.columns)
#if (!$done && $col.readWrite && !$col.immutable)
#if ($col.typeName == "java.lang.String" && $col.length)
    retVal = object.${col.getterName}().equals("${dto.name}.${col.name} updated".substring(0, "${dto.name}.${col.name} updated".length() < $col.length ? "${dto.name}.${col.name} updated".length() : $col.length));
#set ($done = true)
#elseif ($col.typeName == "java.lang.String")
    retVal = object.${col.getterName}().equals("${dto.name}.${col.name} updated");
#set ($done = true)
#elseif ($col.typeName == "java.util.Date")
    java.text.SimpleDateFormat format = 
      new java.text.SimpleDateFormat("M/d/yyyy");
    try {
      java.util.Date date = format.parse("5/14/2009");
      retVal = object.${col.getterName}().equals(date);
    } catch (java.text.ParseException e) {
      assertTrue("Invalid date", false);      
    }
#set ($done = true)
#elseif ($col.typeName == "java.sql.Timestamp")
    java.text.SimpleDateFormat format = 
      new java.text.SimpleDateFormat("M/d/yyyy HH:mm:ss");
    try {
      retVal = object.${col.getterName}().equals(new java.sql.Timestamp(format.parse("5/14/2009 10:55:30").getTime()));
    } catch (java.text.ParseException e) {
      assertTrue("Invalid timestamp", false);      
    }
#set ($done = true)
#elseif ($col.typeName == "short")
    retVal = object.${col.getterName}() == 5;
#set ($done = true)
#elseif ($col.typeName == "java.lang.Short")
    retVal = object.${col.getterName}().equals(5);
#set ($done = true)
#elseif ($col.typeName == "int")
    retVal = object.${col.getterName}() == 123;
#set ($done = true)
#elseif ($col.typeName == "java.lang.Integer")
    retVal = object.${col.getterName}().equals(123);
#set ($done = true)
#elseif ($col.typeName == "long")
    retVal = object.${col.getterName}() == 456L;
#set ($done = true)
#elseif ($col.typeName == "java.lang.Long")
    retVal = object.${col.getterName}().equals(456L);
#set ($done = true)
#elseif ($col.typeName == "float")
    retVal = object.${col.getterName}() == 123.456;
#set ($done = true)
#elseif ($col.typeName == "java.lang.Float")
    retVal = object.${col.getterName}().compareTo(123.456) == 0;
#set ($done = true)
#elseif ($col.typeName == "double")
    retVal = object.${col.getterName}() == 123.456;
#set ($done = true)
#elseif ($col.typeName == "java.lang.Double")
    retVal = object.${col.getterName}().compareTo(123.456) == 0;
#set ($done = true)
#elseif ($col.typeName == "boolean")
    retVal = !originalBooleanValue.equals(object.${col.getterName}());
#set ($done = true)
#elseif ($col.typeName == "java.lang.Boolean")
    retVal = !originalBooleanValue.equals(object.${col.getterName}());
#set ($done = true)
#elseif ($col.typeName == "java.math.BigInteger")
    retVal = object.${col.getterName}().equals(new java.math.BigInteger("123456789"));
#set ($done = true)
#elseif ($col.typeName == "java.math.BigDecimal")
    retVal = 
      object.${col.getterName}().compareTo(new java.math.BigDecimal("12345.6789")) == 0;
#set ($done = true)
#end
## only the above types will result in a test
#end
#end
#if ($done == false)
## No actual update test done, so just set the return to true.
    // No update possible, set return to true.
    retVal = true;
#end
    return retVal;
  }

  /**
   * Is the appropriate column in the input object set to the updated value in 
   * the original object? This method is a helper for the batchUpdate test.
   *
   * @param original the original, updated Bs${dto.name} object
   * @param queried the queried Bs${dto.name} object
   * @return true if the column is updated, false if not
   */
  protected boolean isColumnUpdated(Bs${dto.name} original, Bs${dto.name} queried) {
    boolean retVal = true;
#foreach ($col in $dto.columns)
#if ($col.readWrite && !$col.immutable)
    retVal = 
      retVal && queried.${col.getterName}().equals(original.${col.getterName}());
#end
#end
    return retVal;
  }

  /**
   * Test method for batch update
   * 
   * @throws InvalidParametersException when an invalid parameter prevents the
   *       creation of an object
   * @throws DelegateException when a problem occurs during object creation
   */
  @Test
  public void testUpdateBatch() throws InvalidParametersException,
      DelegateException {
    List<Bs${dto.name}> objects = create${dto.uniqueName}(2);
    delegate.insert(objects);
    // Allocate a map to hold the updated objects for later comparison.
    java.util.Map<com.poesys.db.pk.IPrimaryKey, Bs${dto.name}> map = 
      new java.util.TreeMap<com.poesys.db.pk.IPrimaryKey, Bs${dto.name}>();
    for (Bs${dto.name} object : objects) {
      updateColumn(object);
      // Add the object to the storage map.
      map.put(object.getPrimaryKey(), object);
    }
    delegate.updateBatch(objects);
    
    clearCaches();
    
    for (Bs${dto.name} object : objects) {
      Bs${dto.name} queriedObject = 
        queryStoredObject((${dto.keyClass})object.getPrimaryKey());
      Bs${dto.name} originalObject = map.get(object.getPrimaryKey());
      assertTrue("Object not updated", 
                 isColumnUpdated(originalObject, queriedObject));
    }
#if ($dto.readWrite)
    // Delete the inserted objects to clean up.
    // Mark all the objects for delete.
    for (Bs${dto.name} object : objects) {
      object.delete();
    }

    delegate.deleteBatch(objects);
#end
  }
#end
#if ($dto.removable && $dto.readWrite)

  /**
   * Test method for delete
   * 
   * @throws InvalidParametersException when an invalid parameter prevents the
   *       creation of an object
   * @throws DelegateException when a problem occurs during object creation
   */
  @Test
  public void testDelete() throws InvalidParametersException,
      DelegateException {
    // Create a new ${dto.name} object to perform the test.
    List<Bs${dto.name}> objects = create${dto.uniqueName}(1);
    assertTrue("No object created", objects.get(0) != null);
    delegate.insert(objects);
    ${dto.keyClass} key = 
      (${dto.keyClass})objects.get(0).getPrimaryKey();
    assertTrue("No key for inserted object", key != null);
    Bs${dto.name} insertedObject = objects.get(0);
    assertTrue("No inserted object to delete", insertedObject != null);
    
    insertedObject.delete();
    delegate.delete(insertedObject);
    assertTrue("object not deleted", !exists(key));
#if ($dto.readWrite)
    // Delete the inserted objects to clean up.
    // Mark all the objects for delete.
    for (Bs${dto.name} object : objects) {
      object.delete();
    }

    delegate.deleteBatch(objects);
#end
  }

  /**
   * Test method for deleteBatch
   * 
   * @throws InvalidParametersException when an invalid parameter prevents the
   *       creation of an object
   * @throws DelegateException when a problem occurs during object creation
   */
  @Test
  public void testDeleteBatch() throws InvalidParametersException,
      DelegateException {
    List<Bs${dto.name}> objects = create${dto.uniqueName}(2);
    delegate.insert(objects);
    
    // Mark all the objects for delete.
    for (Bs${dto.name} object : objects) {
      object.delete();
    }

    delegate.deleteBatch(objects);

    for (Bs${dto.name} object : objects) {
      assertTrue("object not deleted", !exists((${dto.keyClass})object.getPrimaryKey()));
    }
  }
#end
#if ($dto.readWrite)

  /**
   * Test method for process()
   * 
   * @throws InvalidParametersException when an invalid parameter prevents the
   *       creation of an object
   * @throws DelegateException when a problem occurs during object creation
   */
  @Test
  public void testProcess() throws InvalidParametersException,
      DelegateException {
    // Create 3 rows--one to insert, one to update, one to delete.
    List<Bs${dto.name}> allObjects = create${dto.uniqueName}(3);
    // Insert the first two rows to later update and delete.
    List<Bs${dto.name}> existingObjects = 
      new CopyOnWriteArrayList<Bs${dto.name}>();
    existingObjects.add(allObjects.get(0));
    existingObjects.add(allObjects.get(1));
    delegate.insert(existingObjects);
#if (!$dto.immutable)
    updateColumn(existingObjects.get(0));
#end
#if ($dto.removable)
    existingObjects.get(1).delete();
#end

    // Set the third object as the object to insert.
    List<Bs${dto.name}> insertObject = 
      new CopyOnWriteArrayList<Bs${dto.name}>();
    insertObject.add(allObjects.get(2));
    
    // Put it all together.
    List<Bs${dto.name}> objects = 
      new CopyOnWriteArrayList<Bs${dto.name}>(existingObjects);
    objects.addAll(insertObject);

    // Test the process method
    delegate.process(objects);

#if (!$dto.immutable)
    // Verify the update
    Bs${dto.name} queriedObject = 
      queryStoredObject((${dto.keyClass})existingObjects.get(0).getPrimaryKey());
    assertTrue("Update not processed", isColumnUpdated(queriedObject));

#end
#if ($dto.removable)
    // Verify the delete
    assertTrue("object not deleted", !exists((${dto.keyClass})existingObjects.get(1).getPrimaryKey()));

#end
    // Verify the insert
    assertTrue("object not inserted", exists((${dto.keyClass})insertObject.get(0).getPrimaryKey()));
    
#if ($dto.readWrite)
    // Delete the inserted objects to clean up.
    // Mark all the objects for delete.
    for (Bs${dto.name} object : allObjects) {
      object.delete();
    }

    delegate.deleteBatch(allObjects);
#end
  }
#end
#foreach ($child in $dto.childProperties)
#set ($childDto = $child.dto)
## Produce a test method only for composite aggregations, not associations,
## and don't produce an update test method for immutable parents or read-only/immutable children.
## TODO Add a TestInsertWithChild method to test inserting a parent with a child
#if ($childDto.keyType == "CompositeKey" && !$dto.immutable && $dto.readWrite && $childDto.readWrite && !$child.immutable)

  /**
   * Test the creation and adding of a child Bs${childDto.name} object to the Bs${dto.name}
   * as a ${child.name} link.
#if ($child.lazy)
   *
   * @throws SQLException when there is a database problem with querying a
   *           lazily loaded associated object
#end
   */
  @Test
  public void testUpdateAdd${stringUtils.capitalize($child.name)}${childDto.name}() #if ($child.lazy) throws java.sql.SQLException#end {
    // Create a new Bs${dto.name} object to perform the test.
    List<Bs${dto.name}> objects = create${dto.uniqueName}(1);
    assertTrue("No object created", objects.get(0) != null);
    delegate.insert(objects);
    ${dto.keyClass} key = 
      (${dto.keyClass})objects.get(0).getPrimaryKey();
    assertTrue("No key for inserted object", key != null);

    // Test to make sure the object is there.
    Bs${dto.name} queriedObject = queryStoredObject(key);
    assertTrue("No queried inserted object", queriedObject != null);
    assertTrue("Wrong object", objects.get(0).equals(queriedObject));

    // Add a child and update the parent to insert the child.
    List<Bs${childDto.name}> children = create${childDto.uniqueName}(queriedObject.toDto(), 1);
    queriedObject.add${stringUtils.capitalize($child.name)}${child.dto.name}(children.get(0));
    delegate.update(queriedObject);
    
    // Test to make sure the object is there.
    Bs${dto.name} queriedUpdatedObject = queryStoredObject(key);
    assertTrue("No queried updated object", queriedUpdatedObject != null);
    assertTrue("Wrong object", objects.get(0).equals(queriedUpdatedObject));
    assertTrue("No ${child.name}, ${childDto.name} not inserted", 
               queriedUpdatedObject.${child.getterName}().size() == 1);
#if ($dto.readWrite)
    // Delete the inserted objects to clean up.
    // Mark all the objects for delete.
    for (Bs${dto.name} object : objects) {
      object.delete();
    }

    delegate.deleteBatch(objects);
#end
  }
#end
#end
#if ($dto.readWrite)

  /**
   * Test method for truncateTable
   */
  @Test
  public void testTruncateTable() {
    delegate.truncateTable("${dto.sqlTableName}");
    List<Bs${dto.name}> objects = delegate.getAllObjects(100);
    assertTrue("Couldn't create list", objects != null);
    // The list should be empty.
    assertTrue("Table not truncated", objects.size() == 0);
  }
#end

  /**
   * Return the database access subsystem name to use to look up access
   * properties in the database.properties file. The concrete implementation
   * should override this method to provide a different subsystem name if
   * needed.
   * 
   * @return the database access subsystem name
   */
  protected String getSubsystem() {
    return subsystem;
  }
}
